{"version":3,"sources":["../src/actions/createWallet.ts","../src/providers/wallet.ts","../src/enviroment.ts","../src/utils/wallet.ts","../src/utils/encryption.ts","../src/actions/ejectWallet.ts","../src/actions/signMessage.ts","../src/actions/loadWallet.ts","../src/actions/validateSignature.ts","../src/actions/getBalance.ts","../src/services/api-service.ts","../src/actions/getBlockInfo.ts","../src/actions/getBlockEvents.ts","../src/actions/getReferenda.ts","../src/actions/getReferendumDetails.ts","../src/providers/networkData.ts","../src/index.ts"],"sourcesContent":["import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\n\nexport interface CreateWalletContent extends Content {\n    encryptionPassword?: string;\n    keypairPassword?: string;\n    hardDerivation?: string;\n    softDerivation?: string;\n}\n\n// Define a schema for input JSON that must include a password.\nexport const passwordSchema = z.object({\n    encryptionPassword: z.string().optional().nullable(),\n    keypairPassword: z.string().optional().nullable(),\n    hardDerivation: z.string().optional().nullable(),\n    softDerivation: z.string().optional().nullable(),\n});\n\n// Define a template to guide object building\nexport const passwordTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"encryptionPassword\": \"<your password here>\",\n    \"keypairPassword\": \"<optional password for keypair>\",\n    \"hardDerivation\": \"<optional hard derivation path>\",\n    \"softDerivation\": \"<optional soft derivation path>\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  If an encryption password is not provided in the latest message, return null for the encryption password.\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\n/**\n * Builds and validates a password object using the provided runtime, message, and state.\n * This function mimics the object building approach used in the mint NFT action.\n */\nexport async function buildCreateWalletDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<{ content: CreateWalletContent; wasPasswordGenerated: boolean }> {\n    // Compose the current state (or create one based on the message)\n    const currentState = state || (await runtime.composeState(message));\n\n    // Compose a context to drive the object geSneration.\n    const context = composeContext({\n        state: currentState,\n        template: passwordTemplate,\n    });\n\n    // Generate an object using the defined schema.\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: passwordSchema as z.ZodTypeAny,\n        modelClass: ModelClass.SMALL,\n    });\n\n    let passwordData = result.object as CreateWalletContent | undefined;\n    let wasPasswordGenerated = false;\n\n    // If passwordData is undefined or encryptionPassword is not available, generate one.\n    if (!passwordData?.encryptionPassword) {\n        const generatedPassword = Math.random().toString(36).slice(-12); // Generate a 12-character random password\n        elizaLogger.log('Encryption password not provided by user, generating one.');\n        // Ensure passwordData is an object before spreading. If it was undefined, initialize it.\n        // If passwordData was undefined, initialize with a default text. Otherwise, use existing passwordData.\n        const baseData = passwordData || { text: '' }; // Provide default text if passwordData is null/undefined\n        passwordData = { ...baseData, encryptionPassword: generatedPassword };\n        wasPasswordGenerated = true;\n    }\n\n    // At this point, passwordData is guaranteed to be defined and have an encryptionPassword.\n    const createWalletContent: CreateWalletContent = passwordData;\n\n    return { content: createWalletContent, wasPasswordGenerated };\n}\n\nexport class CreateWalletAction {\n    private runtime: IAgentRuntime;\n    private walletProvider: WalletProvider;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async initialize(): Promise<void> {\n        this.walletProvider = await initWalletProvider(this.runtime);\n    }\n\n    async createWallet(params: {\n        encryptionPassword: string;\n        keypairPassword?: string;\n        hardDerivation?: string;\n        softDerivation?: string;\n    }): Promise<{\n        walletAddress: string;\n        mnemonic: string;\n        walletNumber: number;\n    }> {\n        const { walletProvider, mnemonic, walletNumber } = await WalletProvider.generateNew(\n            this.walletProvider,\n            params.encryptionPassword,\n            {\n                password: params.keypairPassword,\n                hardDerivation: params.hardDerivation,\n                softDerivation: params.softDerivation,\n            },\n        );\n        const walletAddress = walletProvider.getAddress();\n\n        // Store the new wallet in cache\n        await WalletProvider.storeWalletInCache(walletAddress, walletProvider);\n\n        return { walletAddress, mnemonic, walletNumber };\n    }\n}\n\nexport default {\n    name: 'CREATE_POLKADOT_WALLET',\n    similes: ['NEW_POLKADOT_WALLET', 'MAKE_NEW_POLKADOT_WALLET'],\n    description:\n        'Creates a new Polkadot wallet on demand. Returns the public address and mnemonic backup (store it securely). The wallet keypair is also encrypted to a file using the provided password. Optionally supports keypair password and derivation paths.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting CREATE_POLKADOT_WALLET action...');\n\n        // Build password details using the object building approach\n        const { content: createWalletContent, wasPasswordGenerated: isPasswordGenerated } =\n            await buildCreateWalletDetails(runtime, message, state);\n\n        elizaLogger.debug('createWalletContent', createWalletContent);\n\n        if (!createWalletContent || typeof createWalletContent.encryptionPassword !== 'string') {\n            elizaLogger.error('Failed to obtain encryption password.');\n            if (callback) {\n                callback({\n                    text: 'Unable to process create wallet request. Could not obtain an encryption password.',\n                    content: {\n                        error: 'Invalid create wallet. Password could not be determined or generated.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            // Generate a new wallet using the provided password and options\n            const action = new CreateWalletAction(runtime);\n            await action.initialize();\n\n            const { walletAddress, mnemonic, walletNumber } = await action.createWallet({\n                encryptionPassword: createWalletContent.encryptionPassword,\n                keypairPassword: createWalletContent.keypairPassword,\n                hardDerivation: createWalletContent.hardDerivation,\n                softDerivation: createWalletContent.softDerivation,\n            });\n\n            // Build the user message based on what options were used\n            let userMessageText = `\nNew Polkadot wallet created! ðŸŽ‰\n\nWallet Number: ${walletNumber}\nThis wallet number can be used to load and interact with your wallet in future sessions.`;\n\n            if (isPasswordGenerated) {\n                userMessageText += `\\n\\nGenerated Encryption Password: ${createWalletContent.encryptionPassword}\nâš ï¸ IMPORTANT: Please store this password securely. You'll need it to access your wallet backup.`;\n            }\n\n            userMessageText += `\\n\\nWallet Address: ${walletAddress}`;\n\n            if (createWalletContent.keypairPassword) {\n                userMessageText += `\\nKeypair Password: ${createWalletContent.keypairPassword}`;\n            }\n            if (createWalletContent.hardDerivation) {\n                userMessageText += `\\nHard Derivation: ${createWalletContent.hardDerivation}`;\n            }\n            if (createWalletContent.softDerivation) {\n                userMessageText += `\\nSoft Derivation: ${createWalletContent.softDerivation}`;\n            }\n\n            userMessageText += `\\n\\nâš ï¸ IMPORTANT: Please securely store your mnemonic phrase:\\n${mnemonic}`;\n\n            const result = {\n                status: 'success',\n                walletAddress,\n                walletNumber,\n                mnemonic,\n                keypairPassword: createWalletContent.keypairPassword,\n                hardDerivation: createWalletContent.hardDerivation,\n                softDerivation: createWalletContent.softDerivation,\n                message: 'New Polkadot wallet created. Store the mnemonic securely for recovery.',\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error creating wallet:', error);\n            if (callback) {\n                callback({\n                    text: `Error creating wallet: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Please create a new Polkadot wallet with keypair password 'secret' and hard derivation 'test'\",\n                    action: 'CREATE_POLKADOT_WALLET',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'New Polkadot wallet created!\\nYour password was used to encrypt the wallet keypair, but never stored.\\nWallet Address: EQAXxxxxxxxxxxxxxxxxxxxxxx\\nWallet Number: 1\\nKeypair Password: secret\\nHard Derivation: test\\n\\nPlease securely store your mnemonic:',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Please create a new wallet',\n                    action: 'CREATE_POLKADOT_WALLET',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'New Polkadot wallet created!\\nWallet Number: 1\\nWallet Address: EQAXxxxxxxxxxxxxxxxxxxxxxx\\n\\nPlease securely store your mnemonic:',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, ICacheManager, Memory, Provider, State } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\nimport { CacheManager, MemoryCacheAdapter } from '@elizaos/core';\n\nimport * as path from 'node:path'; // Changed to use node: protocol\nimport type BigNumber from 'bignumber.js';\nimport { CONFIG_KEYS } from '../enviroment';\n\nimport { Keyring } from '@polkadot/keyring';\nimport { cryptoWaitReady, mnemonicGenerate } from '@polkadot/util-crypto';\nimport type { KeyringOptions } from '@polkadot/keyring/types';\n\nimport fs from 'node:fs';\nimport { fetchPrices, getFormattedPortfolio } from '../utils/wallet';\nimport { encrypt, decrypt } from '../utils/encryption';\n\nexport const PROVIDER_CONFIG = {\n    NATIVE_TOKEN_SYMBOL: 'DOT',\n    COINMARKETCAP_API_URL: 'https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest',\n    MAX_RETRIES: 3,\n    RETRY_DELAY: 2000,\n    NATIVE_TOKEN_DECIMALS: BigInt(10000000000),\n    WALLET_BACKUP_DIRNAME: 'polkadot_wallet_backups',\n    DEFAULT_KEYRING_TYPE: 'ed25519' as const,\n    DEFAULT_KEYRING_SS58_FORMAT: 42, // substrate generic, 2 for kusama, 0 for polkadot\n};\n\ninterface WalletData {\n    source: WalletProviderSource;\n    address: string;\n    createdAt: number;\n    decryptedKeyring?: {\n        type: KeyringOptions['type'];\n        mnemonic: string;\n        options: KeyringOptions;\n    };\n}\n\nexport interface OptimizedWalletCache {\n    wallets: {\n        [address: string]: {\n            number: number;\n            createdAt: number;\n            sourceType: WalletSourceType;\n            encryptedData?: string;\n            mnemonicData?: {\n                mnemonic: string;\n                options: KeyringOptions;\n            };\n        };\n    };\n    numberToAddress: {\n        [number: number]: string;\n    };\n}\n\n// Replace multiple cache keys with a single one\nexport const WALLET_CACHE_KEY = 'polkadot/wallets';\n\n// --- Enum and Interfaces for Constructor --- //\nexport enum WalletSourceType { // Exported for potential external use\n    FROM_MNEMONIC = 'fromMnemonic',\n    FROM_ENCRYPTED_JSON = 'fromEncryptedJson',\n}\n\ninterface WalletSourceFromMnemonic {\n    type: WalletSourceType.FROM_MNEMONIC;\n    mnemonic: string;\n    keyringOptions?: KeyringOptions;\n    password?: string;\n    hardDerivation?: string;\n    softDerivation?: string;\n}\ninterface WalletSourceFromEncryptedJson {\n    type: WalletSourceType.FROM_ENCRYPTED_JSON;\n    encryptedJson: string;\n    password: string;\n}\n\ntype WalletProviderSource = WalletSourceFromMnemonic | WalletSourceFromEncryptedJson;\n\nexport interface WalletProviderConstructionParams {\n    // Exporting for potential external use\n    cacheManager: ICacheManager;\n    source: WalletProviderSource;\n}\n// --- End Interfaces --- //\n\nexport class WalletProvider {\n    keyring: Keyring;\n    cacheManager: ICacheManager;\n    coinMarketCapApiKey: string;\n    walletNumber: number | null = null;\n    source: WalletProviderSource;\n\n    constructor(params: WalletProviderConstructionParams) {\n        this.cacheManager =\n            process.env[CONFIG_KEYS.USE_CACHE_MANAGER] !== 'false'\n                ? params.cacheManager\n                : new CacheManager(new MemoryCacheAdapter());\n        this.coinMarketCapApiKey = process.env.COINMARKETCAP_API_KEY || '';\n        if (!this.coinMarketCapApiKey) {\n            elizaLogger.warn('COINMARKETCAP_API_KEY is not set. Price fetching will likely fail.');\n        }\n\n        const { source } = params;\n        this.source = source;\n\n        try {\n            // Reinstating the in-constructor dispatch map\n            const dispatchMap: Record<WalletSourceType, () => void> = {\n                [WalletSourceType.FROM_MNEMONIC]: () =>\n                    this._initializeFromMnemonic(source as WalletSourceFromMnemonic),\n                [WalletSourceType.FROM_ENCRYPTED_JSON]: () =>\n                    this._initializeFromEncryptedJson(source as WalletSourceFromEncryptedJson),\n            };\n\n            // Execute the appropriate initialization function from the map\n            dispatchMap[source.type]();\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`WalletProvider constructor failed: ${message}`);\n            throw new Error(`Failed to initialize WalletProvider: ${message}`);\n        }\n\n        if (!this.keyring || this.keyring.getPairs().length === 0) {\n            throw new Error(\n                `Keypair not loaded into keyring after initialization from source: ${source.type}`,\n            );\n        }\n    }\n\n    static async storeWalletInCache(\n        address: string,\n        wallet: WalletProvider,\n        walletNumber?: number,\n    ): Promise<void> {\n        elizaLogger.debug('Starting storeWalletInCache for address:', address);\n\n        let cache: OptimizedWalletCache;\n        try {\n            const cachedData =\n                await wallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n            if (cachedData) {\n                elizaLogger.debug('Retrieved existing cache');\n                cache = cachedData;\n            } else {\n                elizaLogger.debug('No existing cache found, creating new one');\n                cache = {\n                    wallets: {},\n                    numberToAddress: {},\n                };\n            }\n        } catch (error) {\n            elizaLogger.error('Error retrieving cache, creating new one:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            cache = {\n                wallets: {},\n                numberToAddress: {},\n            };\n        }\n\n        const finalWalletNumber =\n            walletNumber ?? (await WalletProvider.getWalletNumberFromCache(address, cache));\n        elizaLogger.debug('Assigned wallet number:', finalWalletNumber);\n\n        // Only store serializable data\n        const walletData = {\n            number: finalWalletNumber,\n            createdAt: Date.now(),\n            sourceType: wallet.source.type,\n            ...(wallet.source.type === WalletSourceType.FROM_MNEMONIC && {\n                mnemonicData: {\n                    mnemonic: wallet.source.mnemonic,\n                    options: wallet.source.keyringOptions || {\n                        type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n                        ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n                    },\n                },\n            }),\n            ...(wallet.source.type === WalletSourceType.FROM_ENCRYPTED_JSON && {\n                encryptedData: wallet.source.encryptedJson,\n            }),\n        };\n\n        cache.wallets[address] = walletData;\n        cache.numberToAddress[finalWalletNumber] = address;\n\n        try {\n            await wallet.cacheManager.set(WALLET_CACHE_KEY, cache);\n            elizaLogger.debug('Successfully stored wallet in cache');\n        } catch (error) {\n            elizaLogger.error('Failed to store wallet in cache:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw new Error(\n                `Failed to store wallet in cache: ${\n                    error instanceof Error ? error.message : String(error)\n                }`,\n            );\n        }\n    }\n\n    private static async getWalletNumberFromCache(\n        address: string,\n        cache: OptimizedWalletCache,\n    ): Promise<number | null> {\n        return cache.wallets[address]?.number || null;\n    }\n\n    private static getNextWalletNumberFromFilesystem(): number {\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        if (!fs.existsSync(backupDir)) {\n            return 1;\n        }\n\n        try {\n            const files = fs.readdirSync(backupDir);\n            // If no files exist, this is the first wallet\n            if (files.length === 0) {\n                return 1;\n            }\n            // Otherwise, this wallet gets the next number\n            return files.length;\n        } catch (_error) {\n            return 1;\n        }\n    }\n\n    static async clearWalletFromCache(wallet: WalletProvider, address: string): Promise<void> {\n        const cache = await wallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (!cache) return;\n\n        const walletNumber = cache.wallets[address]?.number;\n        if (walletNumber) {\n            delete cache.numberToAddress[walletNumber];\n        }\n        delete cache.wallets[address];\n\n        await wallet.cacheManager.set(WALLET_CACHE_KEY, cache);\n    }\n\n    static async clearAllWalletsFromCache(wallet: WalletProvider): Promise<void> {\n        await wallet.cacheManager.set(WALLET_CACHE_KEY, {\n            wallets: {},\n            numberToAddress: {},\n        });\n    }\n\n    static async loadWalletByAddress(\n        wallet: WalletProvider,\n        address: string,\n        password?: string,\n    ): Promise<WalletProvider> {\n        // First check cache\n        const cache = await wallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (cache?.wallets[address]) {\n            const walletData = cache.wallets[address];\n            if (walletData.mnemonicData) {\n                return new WalletProvider({\n                    cacheManager: wallet.cacheManager,\n                    source: {\n                        type: WalletSourceType.FROM_MNEMONIC,\n                        mnemonic: walletData.mnemonicData.mnemonic,\n                        keyringOptions: walletData.mnemonicData.options,\n                    },\n                });\n            }\n            if (walletData.encryptedData && password) {\n                return new WalletProvider({\n                    cacheManager: wallet.cacheManager,\n                    source: {\n                        type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                        encryptedJson: walletData.encryptedData,\n                        password,\n                    },\n                });\n            }\n            if (walletData.encryptedData && !password) {\n                throw new Error(\n                    `Wallet found in cache but no password provided for address ${address}`,\n                );\n            }\n        }\n\n        // If not in cache, check file system\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        const fileName = `${address}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error(`No stored data found for wallet address ${address}`);\n        }\n\n        if (!password) {\n            throw new Error(\n                `Wallet found in file system but no password provided for address ${address}`,\n            );\n        }\n\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n\n        const walletProvider = new WalletProvider({\n            cacheManager: wallet.cacheManager,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedFileContent,\n                password,\n            },\n        });\n\n        // Store in cache for future use\n        await WalletProvider.storeWalletInCache(address, walletProvider);\n        return walletProvider;\n    }\n\n    static async loadWalletByNumber(\n        wallet: WalletProvider,\n        number: number,\n        password?: string,\n    ): Promise<WalletProvider> {\n        // First check cache\n        const cache = await wallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (cache?.numberToAddress[number]) {\n            const address = cache.numberToAddress[number];\n            const walletData = cache.wallets[address];\n\n            if (walletData.mnemonicData) {\n                return new WalletProvider({\n                    cacheManager: wallet.cacheManager,\n                    source: {\n                        type: WalletSourceType.FROM_MNEMONIC,\n                        mnemonic: walletData.mnemonicData.mnemonic,\n                        keyringOptions: walletData.mnemonicData.options,\n                    },\n                });\n            }\n            if (walletData.encryptedData && password) {\n                return new WalletProvider({\n                    cacheManager: wallet.cacheManager,\n                    source: {\n                        type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                        encryptedJson: walletData.encryptedData,\n                        password,\n                    },\n                });\n            }\n            if (walletData.encryptedData && !password) {\n                throw new Error(`Wallet #${number} found in cache but no password provided`);\n            }\n        }\n\n        // If not in cache, check file system\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        if (!fs.existsSync(backupDir)) {\n            throw new Error(`No wallet found with number ${number}`);\n        }\n\n        const files = fs.readdirSync(backupDir);\n        if (number <= 0 || number > files.length) {\n            throw new Error(`No wallet found with number ${number}`);\n        }\n\n        if (!password) {\n            throw new Error(`Wallet #${number} found in file system but no password provided`);\n        }\n\n        const targetFile = files[number - 1];\n        const filePath = path.join(backupDir, targetFile);\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n\n        const walletProvider = new WalletProvider({\n            cacheManager: wallet.cacheManager,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedFileContent,\n                password,\n            },\n        });\n\n        // Store in cache for future use\n        await WalletProvider.storeWalletInCache(walletProvider.getAddress(), walletProvider);\n        return walletProvider;\n    }\n\n    // Private handler methods for initialization logic\n    private _initializeFromMnemonic(source: WalletSourceFromMnemonic): void {\n        try {\n            elizaLogger.debug('Initializing wallet from mnemonic');\n            const opts = source.keyringOptions || {\n                type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n                ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n            };\n            elizaLogger.debug('Using keyring options:', opts);\n\n            this.keyring = new Keyring(opts);\n\n            // Build the SURI with optional password and derivations\n            let suri = source.mnemonic;\n            if (source.password) {\n                suri = `${suri}///${source.password}`;\n            }\n            if (source.hardDerivation) {\n                suri = `${suri}//${source.hardDerivation}`;\n            }\n            if (source.softDerivation) {\n                suri = `${suri}/${source.softDerivation}`;\n            }\n            elizaLogger.debug('Generated SURI:', suri);\n\n            this.keyring.addFromUri(suri, { name: 'main pair' }, opts.type);\n            elizaLogger.debug('Wallet initialized successfully');\n        } catch (error) {\n            elizaLogger.error('Error initializing from mnemonic:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw new Error(`Failed to initialize wallet from mnemonic: ${error.message}`);\n        }\n    }\n\n    private _initializeFromEncryptedJson(source: WalletSourceFromEncryptedJson): void {\n        try {\n            elizaLogger.debug('Initializing wallet from encrypted JSON');\n            elizaLogger.debug('Encrypted data length:', source.encryptedJson.length);\n\n            const decryptedJson = decrypt(source.encryptedJson, source.password);\n            elizaLogger.debug('Decrypted JSON length:', decryptedJson.length);\n            elizaLogger.debug('Decrypted JSON content:', decryptedJson);\n\n            let MnemonicAndOptions: {\n                mnemonic: string;\n                options: KeyringOptions;\n            };\n            try {\n                elizaLogger.debug('Attempting to parse decrypted JSON');\n                MnemonicAndOptions = JSON.parse(decryptedJson) as {\n                    mnemonic: string;\n                    options: KeyringOptions;\n                };\n                elizaLogger.debug('Successfully parsed wallet data:', MnemonicAndOptions);\n            } catch (parseError) {\n                elizaLogger.error('JSON Parse Error:', {\n                    error:\n                        parseError instanceof Error\n                            ? {\n                                  message: parseError.message,\n                                  stack: parseError.stack,\n                                  name: parseError.name,\n                              }\n                            : parseError,\n                    json: decryptedJson,\n                });\n                throw new Error(`Failed to parse decrypted wallet data: ${parseError.message}`);\n            }\n\n            if (!MnemonicAndOptions.mnemonic || !MnemonicAndOptions.options) {\n                elizaLogger.error('Missing required fields in parsed data:', MnemonicAndOptions);\n                throw new Error('Decrypted data missing required fields (mnemonic or options)');\n            }\n\n            this.keyring = new Keyring(MnemonicAndOptions.options);\n            this.keyring.addFromUri(\n                MnemonicAndOptions.mnemonic,\n                { name: 'imported main pair' },\n                MnemonicAndOptions.options.type,\n            );\n            elizaLogger.debug('Wallet initialized successfully');\n        } catch (error) {\n            elizaLogger.error('Error initializing from encrypted JSON:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw new Error(`Failed to initialize wallet from encrypted data: ${error.message}`);\n        }\n    }\n\n    async fetchPrices(): Promise<{ nativeToken: { usd: BigNumber } }> {\n        return fetchPrices(this.cacheManager, this.coinMarketCapApiKey);\n    }\n\n    getAddress(): string {\n        const pairs = this.keyring.getPairs();\n        if (pairs.length === 0) {\n            throw new Error('No keypairs available in the keyring to get an address.');\n        }\n        return pairs[0].address;\n    }\n\n    async getWalletNumber(): Promise<number | null> {\n        if (this.walletNumber !== null) {\n            return this.walletNumber;\n        }\n\n        const address = this.getAddress();\n\n        const cache = await this.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        const number = cache?.wallets[address]?.number;\n        this.walletNumber = number !== undefined ? Number(number) : null;\n        return this.walletNumber;\n    }\n\n    static async getWalletData(wallet: WalletProvider, number: number): Promise<WalletData | null> {\n        const cache = await wallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (!cache?.numberToAddress[number]) return null;\n\n        const address = cache.numberToAddress[number];\n        const walletData = cache.wallets[address];\n        if (!walletData) return null;\n\n        return {\n            source: {\n                type: walletData.sourceType,\n                ...(walletData.mnemonicData && {\n                    mnemonic: walletData.mnemonicData.mnemonic,\n                    keyringOptions: walletData.mnemonicData.options,\n                }),\n                ...(walletData.encryptedData && {\n                    encryptedJson: walletData.encryptedData,\n                }),\n            } as WalletProviderSource,\n            address,\n            createdAt: walletData.createdAt,\n        };\n    }\n\n    static async getWalletByAddress(\n        wallet: WalletProvider,\n        address: string,\n    ): Promise<WalletData | null> {\n        const cache = await wallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (!cache?.wallets[address]) return null;\n\n        const walletData = cache.wallets[address];\n        return {\n            source: {\n                type: walletData.sourceType,\n                ...(walletData.mnemonicData && {\n                    mnemonic: walletData.mnemonicData.mnemonic,\n                    keyringOptions: walletData.mnemonicData.options,\n                }),\n                ...(walletData.encryptedData && {\n                    encryptedJson: walletData.encryptedData,\n                }),\n            } as WalletProviderSource,\n            address,\n            createdAt: walletData.createdAt,\n        };\n    }\n\n    static async generateNew(\n        wallet: WalletProvider,\n        password: string,\n        options?: {\n            password?: string;\n            hardDerivation?: string;\n            softDerivation?: string;\n            keyringOptions?: KeyringOptions;\n        },\n    ): Promise<{\n        walletProvider: WalletProvider;\n        mnemonic: string;\n        encryptedBackup: string;\n        walletNumber: number;\n    }> {\n        const mnemonic = mnemonicGenerate(24);\n\n        const keyringOptions: KeyringOptions = options?.keyringOptions || {\n            type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n            ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n        };\n\n        // Create a clean object with only the necessary properties\n        const dataToEncrypt = {\n            mnemonic,\n            options: keyringOptions,\n            ...(options?.password && { password: options.password }),\n            ...(options?.hardDerivation && {\n                hardDerivation: options.hardDerivation,\n            }),\n            ...(options?.softDerivation && {\n                softDerivation: options.softDerivation,\n            }),\n        };\n\n        // Ensure proper JSON stringification\n        const jsonString = JSON.stringify(dataToEncrypt);\n\n        try {\n            const encryptedMnemonicAndOptions = encrypt(jsonString, password);\n\n            const walletProvider = new WalletProvider({\n                cacheManager: wallet.cacheManager,\n                source: {\n                    type: WalletSourceType.FROM_MNEMONIC,\n                    mnemonic,\n                    keyringOptions,\n                    password: options?.password,\n                    hardDerivation: options?.hardDerivation,\n                    softDerivation: options?.softDerivation,\n                },\n            });\n\n            const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n            if (!fs.existsSync(backupDir)) {\n                fs.mkdirSync(backupDir, { recursive: true });\n            }\n            const address = walletProvider.getAddress();\n\n            const fileName = `${address}_wallet_backup.json`;\n            const filePath = path.join(backupDir, fileName);\n\n            if (!fs.existsSync(path.dirname(filePath))) {\n                fs.mkdirSync(path.dirname(filePath), { recursive: true });\n            }\n\n            fs.writeFileSync(filePath, encryptedMnemonicAndOptions, {\n                encoding: 'utf-8',\n            });\n            elizaLogger.log(`Wallet backup saved to ${filePath}`);\n\n            // Get the next wallet number from filesystem\n            const walletNumber = WalletProvider.getNextWalletNumberFromFilesystem();\n\n            // Store wallet data in cache using the existing method with the wallet number\n            await WalletProvider.storeWalletInCache(address, walletProvider, walletNumber);\n\n            return {\n                walletProvider,\n                mnemonic,\n                encryptedBackup: encryptedMnemonicAndOptions,\n                walletNumber,\n            };\n        } catch (error) {\n            elizaLogger.error('Error in wallet generation:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw error;\n        }\n    }\n\n    static async importWalletFromFile(\n        runtime: IAgentRuntime,\n        walletAddressForBackupName: string,\n        password: string,\n    ): Promise<WalletProvider> {\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        const fileName = `${walletAddressForBackupName}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error(`Wallet backup file does not exist at: ${filePath}`);\n        }\n\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n\n        const constructionParams: WalletProviderConstructionParams = {\n            cacheManager: runtime.cacheManager,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedFileContent,\n                password,\n            },\n        };\n        return new WalletProvider(constructionParams);\n    }\n\n    static async ejectWalletFromFile(\n        wallet: WalletProvider,\n        walletAddressForBackupName: string,\n        password: string,\n    ): Promise<{ mnemonic: string; options: KeyringOptions }> {\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        const fileName = `${walletAddressForBackupName}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error(`Wallet backup file does not exist at: ${filePath}`);\n        }\n\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n        elizaLogger.debug('Read encrypted file content, length:', encryptedFileContent.length);\n\n        const decryptedFileJson = decrypt(encryptedFileContent, password);\n        elizaLogger.debug('Decrypted file content:', decryptedFileJson);\n\n        try {\n            const mnemonicAndOptions = JSON.parse(decryptedFileJson) as {\n                mnemonic: string;\n                options: KeyringOptions;\n            };\n            elizaLogger.debug('Successfully parsed wallet data:', mnemonicAndOptions);\n            elizaLogger.log(\n                `Wallet ejected from file ${filePath}, revealing mnemonic and options.`,\n            );\n\n            // Get the cache from the current instance\n            await WalletProvider.clearWalletFromCache(wallet, walletAddressForBackupName);\n\n            return mnemonicAndOptions;\n        } catch (parseError) {\n            elizaLogger.error('JSON Parse Error in ejectWalletFromFile:', {\n                error:\n                    parseError instanceof Error\n                        ? {\n                              message: parseError.message,\n                              stack: parseError.stack,\n                              name: parseError.name,\n                          }\n                        : parseError,\n                json: decryptedFileJson,\n            });\n            throw new Error(`Failed to parse decrypted wallet data: ${parseError.message}`);\n        }\n    }\n\n    static async importWallet(\n        encryptedMnemonicAndOptions: string,\n        password: string,\n        runtime: IAgentRuntime,\n    ): Promise<WalletProvider> {\n        const constructionParams: WalletProviderConstructionParams = {\n            cacheManager: runtime.cacheManager,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedMnemonicAndOptions,\n                password,\n            },\n        };\n        const walletProvider = new WalletProvider(constructionParams);\n\n        elizaLogger.log(\n            `Wallet imported successfully via encrypted JSON, address: ${walletProvider.getAddress()}`,\n        );\n        return walletProvider;\n    }\n}\n\nexport const initWalletProvider = async (runtime: IAgentRuntime) => {\n    let mnemonic = runtime.getSetting(CONFIG_KEYS.POLKADOT_PRIVATE_KEY);\n    if (!mnemonic) {\n        elizaLogger.error(`${CONFIG_KEYS.POLKADOT_PRIVATE_KEY} is missing`);\n        mnemonic = mnemonicGenerate(24);\n    }\n\n    const mnemonicsArray = mnemonic.split(' ');\n    if (mnemonicsArray.length < 12 || mnemonicsArray.length > 24) {\n        throw new Error(\n            `${CONFIG_KEYS.POLKADOT_PRIVATE_KEY} mnemonic seems invalid (length: ${mnemonicsArray.length})`,\n        );\n    }\n\n    const keyringOptions: KeyringOptions = {\n        type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n        ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n    };\n\n    await cryptoWaitReady();\n\n    const walletProvider = new WalletProvider({\n        cacheManager: runtime.cacheManager,\n        source: {\n            type: WalletSourceType.FROM_MNEMONIC,\n            mnemonic,\n            keyringOptions,\n        },\n    });\n\n    elizaLogger.log(`Wallet initialized from settings, address: ${walletProvider.getAddress()}`);\n    return walletProvider;\n};\n\nexport const nativeWalletProvider: Provider = {\n    async get(runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<string | null> {\n        const walletProvider = await initWalletProvider(runtime);\n        if (runtime.getSetting('COINMARKETCAP_API_KEY')) {\n            try {\n                const formattedPortfolio = await getFormattedPortfolio(\n                    runtime,\n                    walletProvider.cacheManager,\n                    walletProvider.coinMarketCapApiKey,\n                    walletProvider.getAddress(),\n                );\n                elizaLogger.log(formattedPortfolio);\n                return formattedPortfolio;\n            } catch (error) {\n                const message = error instanceof Error ? error.message : String(error);\n                elizaLogger.error(\n                    `Error in ${PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL.toUpperCase()} wallet provider:`,\n                    message,\n                );\n                return null;\n            }\n        }\n\n        return null;\n    },\n};\n","import type { IAgentRuntime } from '@elizaos/core';\nimport { z } from 'zod';\n\nexport const CONFIG_KEYS = {\n    POLKADOT_PRIVATE_KEY: 'POLKADOT_PRIVATE_KEY',\n    POLKADOT_RPC_URL: 'POLKADOT_RPC_URL',\n    POLKADOT_RPC_API_KEY: 'POLKADOT_RPC_API_KEY',\n    POLKADOT_MANIFEST_URL: 'POLKADOT_MANIFEST_URL',\n    POLKADOT_BRIDGE_URL: 'POLKADOT_BRIDGE_URL',\n    USE_CACHE_MANAGER: 'USE_CACHE_MANAGER',\n} as const;\n\nexport const envSchema = z.object({\n    POLKADOT_PRIVATE_KEY: z.string().min(1, 'private key is required'),\n    POLKADOT_RPC_URL: z.string(),\n    POLKADOT_RPC_API_KEY: z.string(),\n    POLKADOT_MANIFEST_URL: z.string(),\n    POLKADOT_BRIDGE_URL: z.string(),\n});\n\nexport type EnvConfig = z.infer<typeof envSchema>;\n\nexport async function validateEnvConfig(runtime: IAgentRuntime): Promise<EnvConfig> {\n    try {\n        const config = {\n            POLKADOT_PRIVATE_KEY:\n                runtime.getSetting(CONFIG_KEYS.POLKADOT_PRIVATE_KEY) ||\n                process.env.POLKADOT_PRIVATE_KEY,\n            POLKADOT_RPC_URL:\n                runtime.getSetting(CONFIG_KEYS.POLKADOT_RPC_URL) || process.env.POLKADOT_RPC_URL,\n            POLKADOT_RPC_API_KEY:\n                runtime.getSetting(CONFIG_KEYS.POLKADOT_RPC_API_KEY) ||\n                process.env.POLKADOT_RPC_API_KEY,\n            POLKADOT_MANIFEST_URL:\n                runtime.getSetting(CONFIG_KEYS.POLKADOT_MANIFEST_URL) ||\n                process.env.POLKADOT_MANIFEST_URL,\n            POLKADOT_BRIDGE_URL:\n                runtime.getSetting(CONFIG_KEYS.POLKADOT_BRIDGE_URL) ||\n                process.env.POLKADOT_BRIDGE_URL,\n        };\n\n        return envSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join('.')}: ${err.message}`)\n                .join('\\n');\n            throw new Error(`Ton configuration validation failed:\\n${errorMessages}`);\n        }\n        throw error;\n    }\n}\n","import type { IAgentRuntime, ICacheManager } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\nimport BigNumber from 'bignumber.js';\nimport { PROVIDER_CONFIG } from '../providers/wallet';\n\nexport interface WalletPortfolio {\n    totalUsd: string;\n    totalNativeToken: string;\n}\n\nexport async function fetchPrices(\n    cacheManager: ICacheManager,\n    coinMarketCapApiKey: string,\n): Promise<{ nativeToken: { usd: BigNumber } }> {\n    try {\n        const cacheKey = 'prices';\n        const cachedValue = await cacheManager.get<{ nativeToken: { usd: BigNumber } }>(cacheKey);\n\n        if (cachedValue) {\n            elizaLogger.log('Cache hit for fetchPrices');\n            return cachedValue;\n        }\n        elizaLogger.log('Cache miss for fetchPrices');\n\n        let lastError: Error | undefined;\n        for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\n            try {\n                const response = await fetch(\n                    `${PROVIDER_CONFIG.COINMARKETCAP_API_URL}?symbol=${PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL}&convert=USD`,\n                    {\n                        headers: {\n                            'X-CMC_PRO_API_KEY': coinMarketCapApiKey,\n                            Accept: 'application/json',\n                        },\n                    },\n                );\n\n                if (!response.ok) {\n                    const errorText = await response.text();\n                    throw new Error(\n                        `HTTP error! status: ${response.status}, message: ${errorText}`,\n                    );\n                }\n\n                const data = await response.json();\n                const price = data?.data?.[PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL]?.quote?.USD;\n                if (price) {\n                    const prices = {\n                        nativeToken: { usd: new BigNumber(price.price) },\n                    };\n                    cacheManager.set(cacheKey, prices);\n                    return prices;\n                }\n                throw new Error('Price data not found in CoinMarketCap response structure.');\n            } catch (error) {\n                const message = error instanceof Error ? error.message : String(error);\n                elizaLogger.error(`Attempt ${i + 1} failed:`, message);\n                lastError = error instanceof Error ? error : new Error(message);\n                if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\n                    const delay = PROVIDER_CONFIG.RETRY_DELAY * 2 ** i;\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                }\n            }\n        }\n\n        elizaLogger.error('All attempts failed. Throwing the last error:', lastError);\n        throw (\n            lastError ?? new Error('All attempts to fetch prices failed without a specific error.')\n        );\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        elizaLogger.error('Error fetching prices:', message);\n        throw new Error(`Failed to fetch prices: ${message}`);\n    }\n}\n\nexport function formatPortfolio(\n    runtime: IAgentRuntime,\n    portfolio: WalletPortfolio,\n    walletAddress: string,\n): string {\n    let output = `${runtime.character.name}\\n`;\n    output += `Wallet Address: ${walletAddress}\\n`;\n\n    const totalUsdFormatted = new BigNumber(portfolio.totalUsd).toFixed(2);\n    const totalNativeTokenFormatted = new BigNumber(portfolio.totalNativeToken).toFixed(4);\n\n    output += `Total Value: $${totalUsdFormatted} (${totalNativeTokenFormatted} ${PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL.toUpperCase()})\\n`;\n\n    return output;\n}\n\nexport async function fetchPortfolioValue(\n    cacheManager: ICacheManager,\n    coinMarketCapApiKey: string,\n    walletAddress: string,\n): Promise<WalletPortfolio> {\n    try {\n        const cacheKey = `portfolio-${walletAddress}`;\n        const cachedValue = await cacheManager.get<WalletPortfolio>(cacheKey);\n\n        if (cachedValue) {\n            elizaLogger.log('Cache hit for fetchPortfolioValue', cachedValue);\n            return cachedValue;\n        }\n        elizaLogger.log('Cache miss for fetchPortfolioValue');\n\n        const prices = await fetchPrices(cacheManager, coinMarketCapApiKey);\n        const nativeTokenBalance = BigInt(0);\n        const amount = Number(nativeTokenBalance) / Number(PROVIDER_CONFIG.NATIVE_TOKEN_DECIMALS);\n        const totalUsd = new BigNumber(amount.toString()).times(prices.nativeToken.usd);\n\n        const portfolio = {\n            totalUsd: totalUsd.toString(),\n            totalNativeToken: amount.toFixed(4).toString(),\n        };\n\n        cacheManager.set(cacheKey, portfolio);\n        return portfolio;\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        elizaLogger.error('Error fetching portfolio:', message);\n        throw new Error(`Failed to fetch portfolio value: ${message}`);\n    }\n}\n\nexport async function getFormattedPortfolio(\n    runtime: IAgentRuntime,\n    cacheManager: ICacheManager,\n    coinMarketCapApiKey: string,\n    walletAddress: string,\n): Promise<string> {\n    try {\n        const portfolio = await fetchPortfolioValue(\n            cacheManager,\n            coinMarketCapApiKey,\n            walletAddress,\n        );\n        return formatPortfolio(runtime, portfolio, walletAddress);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        elizaLogger.error('Error generating portfolio report:', message);\n        return 'Unable to fetch wallet information. Please try again later.';\n    }\n}\n","import { naclDecrypt, naclEncrypt, randomAsU8a, pbkdf2Encode } from '@polkadot/util-crypto';\nimport { stringToU8a, u8aToString, u8aToHex, hexToU8a } from '@polkadot/util';\nimport { elizaLogger } from '@elizaos/core';\n\n/**\n * Encrypts text using NaCl encryption with PBKDF2 key derivation\n * @param text - The text to encrypt\n * @param password - The password to use for encryption\n * @returns A string containing the encrypted data in format \"kdfSaltHex:nonceHex:encryptedHex\"\n */\nexport function encrypt(text: string, password: string): string {\n    try {\n        if (!text || typeof text !== 'string') {\n            throw new Error('Invalid input text for encryption');\n        }\n        if (!password || typeof password !== 'string') {\n            throw new Error('Invalid password for encryption');\n        }\n\n        const messageU8a = stringToU8a(text);\n        const kdfSalt = randomAsU8a(16); // Salt for PBKDF2\n\n        // Derive a 32-byte key from the password and kdfSalt\n        const { password: secretKey } = pbkdf2Encode(stringToU8a(password), kdfSalt);\n\n        const { encrypted, nonce } = naclEncrypt(messageU8a, secretKey.subarray(0, 32)); // Ensure 32-byte key for nacl\n\n        // Convert kdfSalt, nonce, and encrypted data to hex strings for storage\n        const kdfSaltHex = u8aToHex(kdfSalt);\n        const nonceHex = u8aToHex(nonce);\n        const encryptedHex = u8aToHex(encrypted);\n\n        return `${kdfSaltHex}:${nonceHex}:${encryptedHex}`;\n    } catch (error) {\n        elizaLogger.error('Encryption error:', error);\n        throw new Error(`Failed to encrypt data: ${error.message}`);\n    }\n}\n\n/**\n * Decrypts text that was encrypted using the encrypt function\n * @param encryptedString - The encrypted string in format \"kdfSaltHex:nonceHex:encryptedHex\"\n * @param password - The password used for encryption\n * @returns The decrypted text\n * @throws Error if decryption fails or if the encrypted string format is invalid\n */\nexport function decrypt(encryptedString: string, password: string): string {\n    try {\n        if (!encryptedString || typeof encryptedString !== 'string') {\n            throw new Error('Invalid encrypted string input');\n        }\n        if (!password || typeof password !== 'string') {\n            throw new Error('Invalid password for decryption');\n        }\n\n        const parts = encryptedString.split(':');\n        if (parts.length !== 3) {\n            throw new Error(\n                'Invalid encrypted data format (expected kdfSaltHex:nonceHex:encryptedHex)',\n            );\n        }\n        const [kdfSaltHex, nonceHex, encryptedHex] = parts;\n\n        const kdfSalt = hexToU8a(kdfSaltHex);\n        const nonce = hexToU8a(nonceHex);\n        const encryptedU8a = hexToU8a(encryptedHex);\n\n        // Derive the same 32-byte key from the password and kdfSalt\n        const { password: secretKey } = pbkdf2Encode(stringToU8a(password), kdfSalt);\n\n        const decryptedU8a = naclDecrypt(encryptedU8a, nonce, secretKey.subarray(0, 32)); // Ensure 32-byte key for nacl\n\n        if (!decryptedU8a) {\n            throw new Error('Decryption failed. Invalid password or corrupted data.');\n        }\n\n        const decryptedText = u8aToString(decryptedU8a);\n\n        return decryptedText;\n    } catch (error) {\n        elizaLogger.error('Decryption error:', error.message);\n        throw new Error(`Failed to decrypt data: ${error.message}`);\n    }\n}\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\n\nexport interface EjectWalletContent extends Content {\n    password?: string;\n    walletAddress?: string;\n    walletNumber?: number;\n}\n\nfunction isEjectWalletContent(content: Content): content is EjectWalletContent {\n    return (\n        (typeof content.password === 'string' ||\n            content.password === undefined ||\n            content.password === null) &&\n        (typeof content.walletAddress === 'string' ||\n            content.walletAddress === undefined ||\n            content.walletAddress === null) &&\n        (typeof content.walletNumber === 'number' ||\n            content.walletNumber === undefined ||\n            content.walletNumber === null)\n    );\n}\n\n// Define a schema for input JSON\nconst ejectWalletSchema = z.object({\n    password: z.string().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    walletNumber: z.number().optional().nullable(),\n});\n\n// Define a template to guide object building\nconst ejectWalletTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"password\": \"my_password\",\n  \"walletAddress\": \"EQAXxxxxxxxxxxxxxxxxxxxxxx\",\n  \"walletNumber\": 1\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\n/**\n * Builds and validates eject wallet details using the provided runtime, message, and state.\n */\nexport async function buildEjectWalletDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<EjectWalletContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const context = composeContext({\n        state: currentState,\n        template: ejectWalletTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: ejectWalletSchema as z.ZodTypeAny,\n        modelClass: ModelClass.SMALL,\n    });\n\n    return result.object as EjectWalletContent;\n}\n\nexport default {\n    name: 'EJECT_POLKADOT_WALLET',\n    similes: ['EXPORT_POLKADOT_WALLET', 'RECOVER_WALLET', 'EJECT_WALLET'],\n    description:\n        \"Ejects an existing Polkadot wallet either by wallet number or from an encrypted backup file. Returns the wallet's mnemonic.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting EJECT_POLKADOT_WALLET action...');\n\n        const ejectWalletContent = await buildEjectWalletDetails(runtime, message, state);\n\n        if (!isEjectWalletContent(ejectWalletContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process eject wallet request. Please provide either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid eject wallet request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('ejectWalletContent', ejectWalletContent);\n            const { password, walletAddress, walletNumber } = ejectWalletContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n\n            let mnemonic: string;\n            let address: string;\n\n            // Try to load by wallet number first\n            if (walletNumber) {\n                const targetWallet = await WalletProvider.loadWalletByNumber(\n                    walletProvider,\n                    walletNumber,\n                    password,\n                );\n                if (!targetWallet) {\n                    throw new Error(\n                        `Failed to load wallet #${walletNumber}. Please check the wallet number and password.`,\n                    );\n                }\n                address = targetWallet.getAddress();\n\n                // Try to get mnemonic from decrypted data first\n                const walletData = await WalletProvider.getWalletData(targetWallet, walletNumber);\n                if (walletData?.decryptedKeyring?.mnemonic) {\n                    mnemonic = walletData.decryptedKeyring.mnemonic;\n                } else if (password) {\n                    // Fall back to file system if no decrypted data in cache\n                    elizaLogger.log(\n                        `No decrypted data in cache for wallet #${walletNumber}, falling back to file system`,\n                    );\n                    const result = await WalletProvider.ejectWalletFromFile(\n                        walletProvider,\n                        address,\n                        password,\n                    );\n                    mnemonic = result.mnemonic;\n                } else {\n                    throw new Error(\n                        `No decrypted data found for wallet #${walletNumber} and no password provided for file system fallback`,\n                    );\n                }\n            }\n            // Fall back to file-based ejection if address is provided\n            else if (walletAddress && password) {\n                const result = await WalletProvider.ejectWalletFromFile(\n                    walletProvider,\n                    walletAddress,\n                    password,\n                );\n                mnemonic = result.mnemonic;\n                address = walletAddress;\n            } else {\n                throw new Error(\n                    'Please provide either a wallet number or both wallet address and password.',\n                );\n            }\n\n            const result = {\n                status: 'success',\n                walletAddress: address,\n                mnemonic,\n                message: `\nWallet ejected successfully.\nYour Decrypted mnemonic is:\\n\\n ${mnemonic}.\nPlease store it securely.`,\n            };\n\n            if (callback) {\n                callback({\n                    text: `Wallet ejected successfully.\\n\\nYour Decrypted mnemonic is:\\n\\n ${mnemonic}.\\n\\nPlease store it securely.`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error ejecting wallet:', error);\n            if (callback) {\n                callback({\n                    text: `Error ejecting wallet: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Please eject my Polkadot wallet #1 with password my_password',\n                    action: 'EJECT_POLKADOT_WALLET',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Wallet ejected successfully. Your Decrypted mnemonic is: mnemonic. Please store it securely.',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Please eject my Polkadot wallet with address 1234567890 and password my_password',\n                    action: 'EJECT_POLKADOT_WALLET',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Wallet ejected successfully. Your Decrypted mnemonic is: mnemonic. Please store it securely.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { WalletProvider, initWalletProvider, WALLET_CACHE_KEY } from '../providers/wallet';\nimport { stringToU8a, u8aToHex } from '@polkadot/util'; // For message and signature conversion\nimport { z } from 'zod';\nimport type { OptimizedWalletCache } from '../providers/wallet';\n\n// Interface for the content expected by this action\nexport interface SignMessageContent extends Content {\n    messageToSign: string;\n    walletNumber?: number;\n    walletAddress?: string;\n    walletPassword?: string;\n}\n\nexport interface SignMessageResult {\n    status: 'success';\n    signature: string;\n    walletAddress: string;\n    walletNumber: number;\n    message: string;\n}\n\n// Type guard for SignMessageContent\nfunction isSignMessageContent(content: Content): content is SignMessageContent {\n    return typeof (content as SignMessageContent).messageToSign === 'string';\n}\n\n// Zod schema for input validation\nconst signMessageSchema = z.object({\n    messageToSign: z.string().min(1, 'Message to sign cannot be empty.'),\n    walletNumber: z.number().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    walletPassword: z.string().optional().nullable(),\n});\n\n// Template for AI to extract the message\nconst signMessageTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"messageToSign\": \"This is the message I want to sign.\",\n  \"walletNumber\": 1,\n  \"walletAddress\": \"5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\",\n  \"walletPassword\": \"optional-password-if-specified\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\n/**\n * Builds and validates sign message details object using the provided runtime, message, and state.\n */\nexport async function buildSignMessageDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<SignMessageContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const context = composeContext({\n        state: currentState,\n        template: signMessageTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: signMessageSchema as z.ZodTypeAny,\n        modelClass: ModelClass.SMALL,\n    });\n\n    return result.object as SignMessageContent;\n}\n\nexport class SignMessageAction {\n    private walletProvider: WalletProvider;\n\n    constructor(walletProvider: WalletProvider) {\n        this.walletProvider = walletProvider;\n    }\n\n    async signMessage(\n        messageToSign: string,\n        walletNumber?: number,\n        walletAddress?: string,\n        password?: string,\n    ): Promise<SignMessageResult> {\n        // Validate message is not empty first\n        const messageU8a = stringToU8a(String(messageToSign));\n        if (messageU8a.length === 0) {\n            throw new Error('Cannot sign an empty message');\n        }\n\n        let targetWallet: WalletProvider | null = this.walletProvider;\n        let currentWalletNumber: number | null = null;\n\n        // Try to load by wallet number first\n        if (walletNumber) {\n            targetWallet = await WalletProvider.loadWalletByNumber(\n                this.walletProvider,\n                walletNumber,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet #${walletNumber}. Please check the wallet number.`,\n                );\n            }\n            currentWalletNumber = walletNumber;\n        }\n        // Fall back to loading by address if number fails or address is provided\n        else if (walletAddress) {\n            targetWallet = await WalletProvider.loadWalletByAddress(\n                this.walletProvider,\n                walletAddress,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet with address ${walletAddress}. Please check the address.`,\n                );\n            }\n            // Get wallet number from cache\n            const cache =\n                await targetWallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n            currentWalletNumber = cache?.wallets[walletAddress]?.number || null;\n        }\n\n        const pairs = targetWallet.keyring.getPairs();\n        if (pairs.length === 0) {\n            throw new Error('No key pairs found in the wallet.');\n        }\n\n        // Use the first key pair to sign the message\n        const keypair = pairs[0];\n        const signature = keypair.sign(messageU8a);\n\n        // Store the wallet in cache\n        await WalletProvider.storeWalletInCache(keypair.address, targetWallet);\n\n        return {\n            status: 'success',\n            signature: u8aToHex(signature),\n            walletAddress: keypair.address,\n            walletNumber: currentWalletNumber || 1, // Default to 1 if no number found\n            message: `Message signed successfully. Signature: ${u8aToHex(signature)}`,\n        };\n    }\n}\n\nexport default {\n    name: 'SIGN_POLKADOT_MESSAGE',\n    similes: ['SIGN_MESSAGE', 'SIGN_DATA', 'SIGN_TRANSACTION'],\n    description: 'Signs a message using a Polkadot wallet. Returns the signature.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting SIGN_POLKADOT_MESSAGE action...');\n\n        const signMessageContent = await buildSignMessageDetails(runtime, message, state);\n\n        if (!isSignMessageContent(signMessageContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process sign message request. Please provide a message to sign and either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid sign message request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('signMessageContent', signMessageContent);\n            const { messageToSign, walletNumber, walletAddress } = signMessageContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n            const signAction = new SignMessageAction(walletProvider);\n\n            const result = await signAction.signMessage(\n                String(messageToSign),\n                walletNumber,\n                walletAddress,\n            );\n\n            if (callback) {\n                callback({\n                    text: `Message signed successfully.\\n\\nSignature: ${result.signature}`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error: unknown) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            elizaLogger.error('Error signing message:', errorMessage);\n            if (callback) {\n                callback({\n                    text: `Error signing message: ${errorMessage}`,\n                    content: { error: errorMessage },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Please sign the message 'hello world' with my Polkadot wallet.\",\n                    action: 'SIGN_POLKADOT_MESSAGE',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Message signed successfully!\\nSigner: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\nSignature: 0xabcd1234...',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Can you sign this for me: 'test message 123'\",\n                    action: 'SIGN_POLKADOT_MESSAGE',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Message signed successfully!\\nSigner: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\nSignature: 0xfedc9876...',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\n\n// Interface for the content expected by this action\nexport interface LoadWalletContent extends Content {\n    walletNumber?: number;\n    walletAddress?: string;\n    walletPassword?: string;\n}\n\n// Type guard for LoadWalletContent\nfunction isLoadWalletContent(content: Content): content is LoadWalletContent {\n    return (\n        (typeof content.walletNumber === 'number' ||\n            content.walletNumber === undefined ||\n            content.walletNumber === null) &&\n        (typeof content.walletAddress === 'string' ||\n            content.walletAddress === undefined ||\n            content.walletAddress === null) &&\n        (typeof content.walletPassword === 'string' ||\n            content.walletPassword === undefined ||\n            content.walletPassword === null)\n    );\n}\n\n// Zod schema for input validation\nconst loadWalletSchema = z.object({\n    walletNumber: z.number().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    walletPassword: z.string().optional().nullable(),\n});\n\n// Template for AI to extract the wallet details\nconst loadWalletTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"walletNumber\": 1,\n  \"walletAddress\": \"5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\",\n  \"walletPassword\": \"password\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\n/**\n * Builds and validates load wallet details object using the provided runtime, message, and state.\n */\nexport async function buildLoadWalletDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<LoadWalletContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const context = composeContext({\n        state: currentState,\n        template: loadWalletTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: loadWalletSchema as z.ZodTypeAny,\n        modelClass: ModelClass.SMALL,\n    });\n\n    return result.object as LoadWalletContent;\n}\n\nexport default {\n    name: 'LOAD_POLKADOT_WALLET',\n    similes: ['LOAD_WALLET', 'OPEN_WALLET', 'ACCESS_WALLET'],\n    description:\n        \"Loads an existing Polkadot wallet either by wallet number or address. Returns the wallet's address.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting LOAD_POLKADOT_WALLET action...');\n\n        const loadWalletContent = await buildLoadWalletDetails(runtime, message, state);\n\n        if (!isLoadWalletContent(loadWalletContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process load wallet request. Please provide either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid load wallet request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('loadWalletContent', loadWalletContent);\n            const { walletNumber, walletAddress, walletPassword } = loadWalletContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n\n            let targetWallet: WalletProvider | null = null;\n\n            // Try to load by wallet number first\n            if (walletNumber) {\n                targetWallet = await WalletProvider.loadWalletByNumber(\n                    walletProvider,\n                    walletNumber,\n                    walletPassword,\n                );\n                if (!targetWallet) {\n                    throw new Error(\n                        `Failed to load wallet #${walletNumber}. Please check the wallet number or password.`,\n                    );\n                }\n            }\n            // Fall back to loading by address if number fails or address is provided\n            else if (walletAddress) {\n                targetWallet = await WalletProvider.loadWalletByAddress(\n                    walletProvider,\n                    walletAddress,\n                    walletPassword,\n                );\n                if (!targetWallet) {\n                    throw new Error(\n                        `Failed to load wallet with address ${walletAddress}. Please check the address or password.`,\n                    );\n                }\n            }\n\n            const address = targetWallet.getAddress();\n            const currentWalletNumber = await targetWallet.getWalletNumber();\n\n            // Store the wallet in cache\n            await WalletProvider.storeWalletInCache(address, targetWallet);\n\n            const result = {\n                status: 'success',\n                walletAddress: address,\n                walletNumber: currentWalletNumber,\n                message: `Wallet loaded successfully. Your wallet address is: ${address}${\n                    currentWalletNumber ? ` (Wallet #${currentWalletNumber})` : ''\n                }`,\n            };\n\n            if (callback) {\n                callback({\n                    text: `Wallet loaded successfully.\\n\\nYour wallet address is: ${address}${\n                        currentWalletNumber ? ` (Wallet #${currentWalletNumber})` : ''\n                    }`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error loading wallet:', error);\n            if (callback) {\n                callback({\n                    text: `Error loading wallet: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Please load my Polkadot wallet #1 with password my_password',\n                    action: 'LOAD_POLKADOT_WALLET',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Wallet loaded successfully!\\nWallet #1\\nAddress: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\n\\nThe wallet is now ready for use.',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Please load my Polkadot wallet with address 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb and password my_password',\n                    action: 'LOAD_POLKADOT_WALLET',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Wallet loaded successfully!\\nWallet #1\\nAddress: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\n\\nThe wallet is now ready for use.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { WALLET_CACHE_KEY, WalletProvider, initWalletProvider } from '../providers/wallet';\nimport type { OptimizedWalletCache } from '../providers/wallet';\nimport { stringToU8a, hexToU8a } from '@polkadot/util';\nimport { z } from 'zod';\n\nexport interface ValidateSignatureContent extends Content {\n    message: string;\n    signature: string;\n    walletNumber?: number;\n    walletPassword?: string;\n    walletAddress?: string;\n}\n\nexport interface ValidateSignatureResult {\n    status: 'success';\n    isValid: boolean;\n    walletAddress: string;\n    walletNumber: number;\n    message: string;\n}\n\n// Zod schema for input validation\nconst validateSignatureSchema = z.object({\n    message: z.string().min(1, 'Message cannot be empty.'),\n    signature: z.string().min(1, 'Signature cannot be empty.'),\n    walletNumber: z.number().optional().nullable(),\n    walletPassword: z.string().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n});\n\n// Template for AI to extract the values\nconst validateSignatureTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"message\": \"This is the message to verify\",\n  \"signature\": \"0x...\",\n  \"walletNumber\": 1,\n  \"walletPassword\": \"optional-password-if-specified\",\n  \"walletAddress\": \"optional-address-if-specified\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\nexport class ValidateAction {\n    private walletProvider: WalletProvider;\n\n    constructor(walletProvider: WalletProvider) {\n        this.walletProvider = walletProvider;\n    }\n\n    async validateSignature(\n        messageToVerify: string,\n        signature: string,\n        walletNumber?: number,\n        walletAddress?: string,\n        password?: string,\n    ): Promise<ValidateSignatureResult> {\n        if (!walletNumber && !walletAddress) {\n            throw new Error(\n                'Unable to validate signature. Please provide a wallet number or address.',\n            );\n        }\n        // Validate inputs first\n        if (!messageToVerify) {\n            throw new Error('Cannot validate signature for an empty message');\n        }\n        if (!signature) {\n            throw new Error('Cannot validate an empty signature');\n        }\n\n        let targetWallet: WalletProvider | null = this.walletProvider;\n        let currentWalletNumber: number | null = null;\n\n        // Try to load by wallet number first\n        if (walletNumber) {\n            targetWallet = await WalletProvider.loadWalletByNumber(\n                this.walletProvider,\n                walletNumber,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet #${walletNumber}. Please check the wallet number.`,\n                );\n            }\n            currentWalletNumber = walletNumber;\n        }\n        // Fall back to loading by address if number fails or address is provided\n        else if (walletAddress) {\n            targetWallet = await WalletProvider.loadWalletByAddress(\n                this.walletProvider,\n                walletAddress,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet with address ${walletAddress}. Please check the address.`,\n                );\n            }\n            // Get wallet number from cache\n            const cache =\n                await targetWallet.cacheManager.get<OptimizedWalletCache>(WALLET_CACHE_KEY);\n            currentWalletNumber = cache?.wallets[walletAddress]?.number || null;\n        }\n\n        const pairs = targetWallet.keyring.getPairs();\n        if (pairs.length === 0) {\n            throw new Error('No key pairs found in the wallet.');\n        }\n\n        // Use the first key pair to verify the signature\n        const keypair = pairs[0];\n        const messageU8a = stringToU8a(String(messageToVerify));\n        const signatureU8a = hexToU8a(signature);\n        const isValid = keypair.verify(messageU8a, signatureU8a, keypair.publicKey);\n\n        // Store the wallet in cache\n        await WalletProvider.storeWalletInCache(keypair.address, targetWallet);\n\n        return {\n            status: 'success',\n            isValid,\n            walletAddress: keypair.address,\n            walletNumber: currentWalletNumber || 1, // Default to 1 if no number found\n            message: `Signature validation ${isValid ? 'succeeded' : 'failed'}.`,\n        };\n    }\n}\n\n/**\n * Builds and validates signature verification details object using the provided runtime, message, and state.\n */\nexport async function buildValidateSignatureDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<ValidateSignatureContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const context = composeContext({\n        state: currentState,\n        template: validateSignatureTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: validateSignatureSchema as z.ZodTypeAny,\n        modelClass: ModelClass.SMALL,\n    });\n\n    return result.object as ValidateSignatureContent;\n}\n\n// Type guard for validate signature content\nconst isValidateSignatureContent = (content: unknown): content is ValidateSignatureContent => {\n    return (\n        typeof content === 'object' &&\n        content !== null &&\n        'message' in content &&\n        'signature' in content &&\n        (('walletNumber' in content && typeof content.walletNumber === 'number') ||\n            ('walletAddress' in content && typeof content.walletAddress === 'string'))\n    );\n};\n\nexport default {\n    name: 'VALIDATE_POLKADOT_SIGNATURE',\n    similes: ['VERIFY_SIGNATURE', 'CHECK_SIGNATURE', 'VALIDATE_SIGNATURE'],\n    description:\n        'Validates a signature for a message using a Polkadot wallet. Returns whether the signature is valid.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting VALIDATE_POLKADOT_SIGNATURE action...');\n\n        const validateSignatureContent = await buildValidateSignatureDetails(\n            runtime,\n            message,\n            state,\n        );\n\n        if (!isValidateSignatureContent(validateSignatureContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process validate signature request. Please provide a message, signature, and either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid validate signature request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('validateSignatureContent', validateSignatureContent);\n            const {\n                message: messageToVerify,\n                signature,\n                walletNumber,\n                walletAddress,\n            } = validateSignatureContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n            const validateAction = new ValidateAction(walletProvider);\n\n            const result = await validateAction.validateSignature(\n                messageToVerify,\n                signature,\n                walletNumber,\n                walletAddress,\n            );\n\n            if (callback) {\n                callback({\n                    text: result.message,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error validating signature:', error);\n            if (callback) {\n                callback({\n                    text: `Error validating signature: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Please verify this signature: 0x1234... for message 'hello world'\",\n                    action: 'VALIDATE_POLKADOT_SIGNATURE',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Signature is valid for address 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Check if signature 0x5678... is valid for message 'test' using wallet #1\",\n                    action: 'VALIDATE_POLKADOT_SIGNATURE',\n                },\n            },\n            {\n                user: '{{user2}}',\n                content: {\n                    text: 'Signature is valid for address 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { z } from 'zod';\nimport { formatBalance } from '@polkadot/util';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetBalanceContent extends Content {\n    address: string;\n}\n\nexport const addressSchema = z.object({\n    address: z.string().min(1, 'Address is required'),\n});\n\nexport const addressTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"address\": \"15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetBalanceDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<{ content: GetBalanceContent }> {\n    const currentState = state || (await runtime.composeState(message));\n\n    const context = composeContext({\n        state: currentState,\n        template: addressTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: addressSchema as z.ZodTypeAny,\n        modelClass: ModelClass.MEDIUM,\n    });\n\n    const addressData = result.object as GetBalanceContent;\n\n    if (!addressData || !addressData.address) {\n        throw new Error('Failed to extract a valid Polkadot address from the message');\n    }\n\n    return { content: addressData };\n}\n\nexport class GetBalanceAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getBalance(params: { address: string }): Promise<{\n        address: string;\n        freeBalance: string;\n        reservedBalance: string;\n        totalBalance: string;\n        formattedFreeBalance: string;\n        formattedReservedBalance: string;\n        formattedTotalBalance: string;\n        tokenSymbol: string;\n        tokenDecimals: number;\n    }> {\n        try {\n            elizaLogger.debug('Initializing getBalance for address:', params.address);\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n            elizaLogger.debug('API connection established');\n\n            const accountInfo = await api.query.system.account(params.address);\n            elizaLogger.debug('Account info retrieved:', accountInfo.toHuman());\n            const balance = accountInfo.toJSON() as { data: { free: string; reserved: string } };\n\n            const properties = await api.rpc.system.properties();\n            elizaLogger.debug('Chain properties retrieved:', properties.toHuman());\n            const tokenSymbol = properties.tokenSymbol.unwrap()[0].toString();\n            const tokenDecimals = properties.tokenDecimals.unwrap()[0].toNumber();\n            elizaLogger.debug('Token details:', { tokenSymbol, tokenDecimals });\n\n            formatBalance.setDefaults({\n                decimals: tokenDecimals,\n                unit: tokenSymbol,\n            });\n\n            const freeBalance = balance.data.free.toString();\n            const reservedBalance = balance.data.reserved.toString();\n            const totalBalance = (\n                BigInt(balance.data.free) + BigInt(balance.data.reserved)\n            ).toString();\n            elizaLogger.debug('Balance calculations completed:', {\n                freeBalance,\n                reservedBalance,\n                totalBalance,\n            });\n\n            const formattedFreeBalance = formatBalance(balance.data.free);\n            const formattedReservedBalance = formatBalance(balance.data.reserved);\n            const formattedTotalBalance = formatBalance(\n                BigInt(balance.data.free) + BigInt(balance.data.reserved),\n            );\n            elizaLogger.debug('Formatted balances:', {\n                formattedFreeBalance,\n                formattedReservedBalance,\n                formattedTotalBalance,\n            });\n\n            return {\n                address: params.address,\n                freeBalance,\n                reservedBalance,\n                totalBalance,\n                formattedFreeBalance,\n                formattedReservedBalance,\n                formattedTotalBalance,\n                tokenSymbol,\n                tokenDecimals,\n            };\n        } catch (error) {\n            elizaLogger.error(`Error fetching balance for address ${params.address}:`, error);\n            throw new Error(`Failed to retrieve balance: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_POLKADOT_BALANCE',\n    similes: ['CHECK_POLKADOT_BALANCE', 'VIEW_POLKADOT_BALANCE', 'POLKADOT_BALANCE'],\n    description:\n        'Retrieves the balance information for a Polkadot address, including free, reserved, and total balances.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_POLKADOT_BALANCE action...');\n\n        try {\n            const { content: getBalanceContent } = await buildGetBalanceDetails(\n                runtime,\n                message,\n                state,\n            );\n\n            elizaLogger.debug('getBalanceContent', getBalanceContent);\n\n            if (!getBalanceContent || typeof getBalanceContent.address !== 'string') {\n                elizaLogger.error('Failed to obtain a valid address.');\n                if (callback) {\n                    callback({\n                        text: \"I couldn't process your balance request. Please provide a valid Polkadot address.\",\n                        content: { error: 'Invalid address format or missing address.' },\n                    });\n                }\n                return false;\n            }\n\n            const action = new GetBalanceAction(runtime);\n            const balanceInfo = await action.getBalance({\n                address: getBalanceContent.address,\n            });\n\n            const userMessageText = `\nBalance Information for: ${balanceInfo.address}\n\nFree Balance: ${balanceInfo.formattedFreeBalance}\nReserved Balance: ${balanceInfo.formattedReservedBalance}\nTotal Balance: ${balanceInfo.formattedTotalBalance}\n\nNote: Free balance is the amount available for transfers and transactions. Reserved balance is locked for various on-chain activities.`;\n\n            const result = {\n                status: 'success',\n                address: balanceInfo.address,\n                freeBalance: balanceInfo.freeBalance,\n                reservedBalance: balanceInfo.reservedBalance,\n                totalBalance: balanceInfo.totalBalance,\n                formattedFreeBalance: balanceInfo.formattedFreeBalance,\n                formattedReservedBalance: balanceInfo.formattedReservedBalance,\n                formattedTotalBalance: balanceInfo.formattedTotalBalance,\n                tokenSymbol: balanceInfo.tokenSymbol,\n                tokenDecimals: balanceInfo.tokenDecimals,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving balance:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving balance: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'What is the balance of 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz?',\n                    action: 'GET_POLKADOT_BALANCE',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Balance Information for: 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz\\n\\nFree Balance: 10.5000 DOT\\nReserved Balance: 0.0000 DOT\\nTotal Balance: 10.5000 DOT\\n\\nNote: Free balance is the amount available for transfers and transactions. Reserved balance is locked for various on-chain activities.',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Check the DOT balance in this address: 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz',\n                    action: 'GET_POLKADOT_BALANCE',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Balance Information for: 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz\\n\\nFree Balance: 10.5000 DOT\\nReserved Balance: 0.0000 DOT\\nTotal Balance: 10.5000 DOT\\n\\nNote: Free balance is the amount available for transfers and transactions. Reserved balance is locked for various on-chain activities.',\n                },\n            },\n        ],\n    ],\n};\n","import { elizaLogger } from '@elizaos/core';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { CONFIG_KEYS } from '../enviroment';\nimport { Service, IAgentRuntime, ServiceType } from '@elizaos/core';\n\nconst DEFAULT_NETWORK_CONFIG = {\n    DEFAULT_ENDPOINT: 'wss://rpc.polkadot.io',\n    BACKUP_ENDPOINTS: [\n        'wss://polkadot-rpc.dwellir.com',\n        'wss://polkadot.api.onfinality.io/public-ws',\n        'wss://rpc.ibp.network/polkadot',\n        'wss://polkadot-rpc.publicnode.com',\n    ],\n    MAX_RETRIES: 3,\n    RETRY_DELAY: 2000,\n};\n\n/**\n * Singleton service that manages connection to the Polkadot API\n * Includes connection pooling, retry logic, and endpoint fallback\n */\nexport class PolkadotApiService extends Service {\n    static serviceType = 'polkadot_api' as ServiceType;\n    capabilityDescription = 'The agent is able to interact with the Polkadot API';\n\n    private static _instance: PolkadotApiService | null = null;\n    private api: ApiPromise | null = null;\n    private provider: WsProvider | null = null;\n    private connecting = false;\n    private connectionPromise: Promise<ApiPromise> | null = null;\n    private lastEndpointIndex = 0;\n    private networkConfig = { ...DEFAULT_NETWORK_CONFIG };\n\n    constructor(protected runtime: IAgentRuntime) {\n        super();\n    }\n\n    static async start(runtime: IAgentRuntime): Promise<PolkadotApiService> {\n        if (!PolkadotApiService._instance) {\n            PolkadotApiService._instance = new PolkadotApiService(runtime);\n            await PolkadotApiService._instance.initialize();\n            await PolkadotApiService._instance.connectWithRetry();\n        }\n        return PolkadotApiService._instance;\n    }\n\n    async stop(): Promise<void> {\n        await this.disconnect();\n        PolkadotApiService._instance = null;\n    }\n\n    async initialize(): Promise<void> {\n        const customEndpoint =\n            this.runtime.getSetting(CONFIG_KEYS.POLKADOT_RPC_URL) || process.env.POLKADOT_RPC_URL;\n\n        if (customEndpoint) {\n            this.networkConfig.DEFAULT_ENDPOINT = customEndpoint;\n            elizaLogger.debug(`Using custom Polkadot endpoint: ${customEndpoint}`);\n        } else {\n            elizaLogger.debug(\n                `No custom endpoint found, using default: ${this.networkConfig.DEFAULT_ENDPOINT}`,\n            );\n        }\n    }\n\n    /**\n     * Get a connection to the Polkadot API\n     * If a connection is already established, it will be reused\n     * If no connection exists, a new one will be created\n     * If a connection is being established, the existing promise will be returned\n     */\n    public async getConnection(): Promise<ApiPromise> {\n        if (this.api?.isConnected) {\n            return this.api;\n        }\n\n        if (this.connecting && this.connectionPromise) {\n            return this.connectionPromise;\n        }\n\n        this.connecting = true;\n        this.connectionPromise = this.connectWithRetry();\n\n        try {\n            this.api = await this.connectionPromise;\n            return this.api;\n        } finally {\n            this.connecting = false;\n            this.connectionPromise = null;\n        }\n    }\n\n    /**\n     * Connect to the Polkadot API with retry logic\n     * @param retryCount Current retry attempt number\n     */\n    private async connectWithRetry(retryCount = 0): Promise<ApiPromise> {\n        try {\n            const endpoint = this.getNextEndpoint();\n            elizaLogger.debug(`Connecting to Polkadot at ${endpoint}`);\n\n            this.provider = new WsProvider(endpoint);\n            this.api = await ApiPromise.create({ provider: this.provider });\n\n            elizaLogger.debug(`Connected to Polkadot at ${endpoint}`);\n            return this.api;\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`Polkadot connection error: ${message}`);\n\n            if (retryCount < this.networkConfig.MAX_RETRIES) {\n                const delay = this.networkConfig.RETRY_DELAY * 2 ** retryCount;\n                elizaLogger.debug(`Retrying connection in ${delay}ms...`);\n\n                await new Promise((resolve) => setTimeout(resolve, delay));\n                return this.connectWithRetry(retryCount + 1);\n            }\n\n            throw new Error(\n                `Failed to connect to Polkadot after ${this.networkConfig.MAX_RETRIES} attempts`,\n            );\n        }\n    }\n\n    /**\n     * Get the next endpoint to try from the configured endpoints\n     * This implements a round-robin selection strategy\n     */\n    private getNextEndpoint(): string {\n        const allEndpoints = [\n            this.networkConfig.DEFAULT_ENDPOINT,\n            ...this.networkConfig.BACKUP_ENDPOINTS,\n        ];\n        this.lastEndpointIndex = this.lastEndpointIndex % allEndpoints.length;\n        elizaLogger.debug(`Next endpoint: ${allEndpoints[this.lastEndpointIndex]}`);\n        return allEndpoints[this.lastEndpointIndex];\n    }\n\n    /**\n     * Disconnect from the Polkadot API\n     * This should be called when the application is shutting down\n     */\n    public async disconnect(): Promise<void> {\n        if (this.api) {\n            await this.api.disconnect();\n            this.api = null;\n        }\n\n        if (this.provider) {\n            this.provider.disconnect();\n            this.provider = null;\n        }\n    }\n\n    /**\n     * Check if a connection is currently established\n     */\n    public isConnected(): boolean {\n        return !!this.api && this.api.isConnected;\n    }\n\n    /**\n     * Get information about the current connection\n     * Returns null if no connection is established\n     */\n    public getConnectionInfo(): { endpoint: string; connected: boolean } | null {\n        if (!this.provider) {\n            return null;\n        }\n\n        return {\n            endpoint: this.provider.endpoint,\n            connected: this.isConnected(),\n        };\n    }\n\n    /**\n     * Set custom endpoints for the API connection\n     * This allows endpoints to be configured at runtime\n     * @param endpoints Array of WebSocket endpoints\n     */\n    public setCustomEndpoints(endpoints: string[]): void {\n        if (!endpoints || endpoints.length === 0) {\n            return;\n        }\n\n        // Only update if there's at least one valid endpoint\n        if (endpoints.some((e) => e.startsWith('wss://') || e.startsWith('ws://'))) {\n            // Replace the existing configuration\n            Object.defineProperty(this.networkConfig, 'DEFAULT_ENDPOINT', {\n                value: endpoints[0],\n                writable: true,\n            });\n\n            Object.defineProperty(this.networkConfig, 'BACKUP_ENDPOINTS', {\n                value: endpoints.slice(1),\n                writable: true,\n            });\n\n            // Reset the endpoint index\n            this.lastEndpointIndex = 0;\n            elizaLogger.debug(`Updated Polkadot API endpoints: ${endpoints.join(', ')}`);\n        }\n    }\n}\n\nexport default PolkadotApiService;\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetBlockInfoContent extends Content {\n    blockNumberOrHash: string;\n}\n\n// Define proper types for API responses\ninterface PolkadotBlock {\n    block: {\n        header: {\n            number: { toString: () => string };\n            parentHash: { toString: () => string };\n            stateRoot: { toString: () => string };\n            extrinsicsRoot: { toString: () => string };\n        };\n        extrinsics: { toArray: () => unknown[] };\n    };\n}\n\ninterface PolkadotTimestamp {\n    toNumber: () => number;\n}\n\ninterface PolkadotEvents {\n    toJSON: () => unknown[];\n}\n\nexport const blockInfoSchema = z.object({\n    blockNumberOrHash: z.string().min(1, 'Block number or hash is required'),\n});\n\nexport const blockInfoTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"12345678\" \n  }\n  \\`\\`\\`\n  or\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"0x1a2b3c4d5e6f...\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetBlockInfoDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<{ content: GetBlockInfoContent }> {\n    const currentState = state || (await runtime.composeState(message));\n\n    const context = composeContext({\n        state: currentState,\n        template: blockInfoTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: blockInfoSchema as z.ZodTypeAny,\n        modelClass: ModelClass.MEDIUM,\n    });\n\n    const blockData = result.object as GetBlockInfoContent;\n\n    if (!blockData || !blockData.blockNumberOrHash) {\n        throw new Error('Failed to extract a valid block number or hash from the message');\n    }\n\n    return { content: blockData };\n}\n\n// Helper function to format timestamp\nfunction formatTimestamp(timestamp: string): string {\n    if (timestamp === 'Unknown') {\n        return 'Unknown';\n    }\n\n    try {\n        const date = new Date(timestamp);\n        return `${date.toISOString().replace('T', ' ').slice(0, 19)} UTC`;\n    } catch {\n        return timestamp;\n    }\n}\n\nexport class GetBlockInfoAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getBlockInfo(params: { blockNumberOrHash: string }): Promise<{\n        number: string;\n        hash: string;\n        parentHash: string;\n        stateRoot: string;\n        extrinsicsRoot: string;\n        timestamp: string;\n        extrinsicsCount: number;\n        eventsCount: number;\n    }> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n            let blockHash: string;\n            if (params.blockNumberOrHash.startsWith('0x')) {\n                // This is a hash\n                blockHash = params.blockNumberOrHash;\n            } else {\n                // This is a block number\n                const hashResult = await api.rpc.chain.getBlockHash(\n                    parseInt(params.blockNumberOrHash),\n                );\n                blockHash = hashResult.toString();\n            }\n\n            // Get block with extended data\n            const [blockResult, eventsResult, timestampResult] = await Promise.allSettled([\n                api.rpc.chain.getBlock(blockHash),\n                api.query.system.events.at(blockHash),\n                api.query.timestamp?.now\n                    ? api.query.timestamp.now.at(blockHash)\n                    : Promise.resolve(null),\n            ]);\n\n            if (blockResult.status === 'rejected') {\n                throw blockResult.reason;\n            }\n            if (eventsResult.status === 'rejected') {\n                throw eventsResult.reason;\n            }\n\n            const signedBlock = blockResult.value as unknown as PolkadotBlock;\n            const eventsRaw = eventsResult.value as unknown as PolkadotEvents;\n            const timestamp = timestampResult.status === 'fulfilled' ? timestampResult.value : null;\n\n            const block = signedBlock.block;\n            const blockNumber = block.header.number.toString();\n\n            // Convert events to proper format first with proper typing\n            const events = eventsRaw.toJSON() as unknown[];\n\n            // Extract block data\n            const blockInfo = {\n                number: blockNumber,\n                hash: blockHash.toString(),\n                parentHash: block.header.parentHash.toString(),\n                stateRoot: block.header.stateRoot.toString(),\n                extrinsicsRoot: block.header.extrinsicsRoot.toString(),\n                timestamp:\n                    timestamp !== null && timestamp !== undefined\n                        ? new Date(\n                              (timestamp as unknown as PolkadotTimestamp).toNumber(),\n                          ).toISOString()\n                        : 'Unknown',\n                extrinsicsCount: block.extrinsics.toArray().length, // Convert to array first\n                eventsCount: Array.isArray(events) ? events.length : 0,\n            };\n\n            return blockInfo;\n        } catch (error) {\n            elizaLogger.error(`Error fetching block info for ${params.blockNumberOrHash}:`, error);\n            throw new Error(`Failed to retrieve block info: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_BLOCK_INFO',\n    similes: ['VIEW_BLOCK_INFO', 'BLOCK_DETAILS', 'POLKADOT_BLOCK_INFO'],\n    description: 'Retrieves detailed information about a Polkadot block by its number or hash.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_BLOCK_INFO action...');\n\n        try {\n            const { content: getBlockInfoContent } = await buildGetBlockInfoDetails(\n                runtime,\n                message,\n                state,\n            );\n\n            elizaLogger.debug('getBlockInfoContent', getBlockInfoContent);\n\n            if (!getBlockInfoContent || typeof getBlockInfoContent.blockNumberOrHash !== 'string') {\n                elizaLogger.error('Failed to obtain a valid block number or hash.');\n                if (callback) {\n                    callback({\n                        text: \"I couldn't process your block info request. Please provide a valid block number or hash.\",\n                        content: { error: 'Invalid block number or hash format.' },\n                    });\n                }\n                return false;\n            }\n\n            const action = new GetBlockInfoAction(runtime);\n            const blockInfo = await action.getBlockInfo({\n                blockNumberOrHash: getBlockInfoContent.blockNumberOrHash,\n            });\n\n            const timeInfo =\n                blockInfo.timestamp !== 'Unknown'\n                    ? `\\nâ° Time: ${formatTimestamp(blockInfo.timestamp)}`\n                    : '';\n\n            const userMessageText = `\nðŸ“¦ Block ${blockInfo.number} Information\n\nBasic Details:\nâ€¢ Number: ${blockInfo.number}\nâ€¢ Hash: ${blockInfo.hash}\nâ€¢ Parent: ${blockInfo.parentHash}${timeInfo}\n\nMerkle Roots:\nâ€¢ State Root: ${blockInfo.stateRoot}\nâ€¢ Extrinsics Root: ${blockInfo.extrinsicsRoot}\n\nBlock Content:\nâ€¢ ðŸ“‹ Extrinsics: ${blockInfo.extrinsicsCount}\nâ€¢ ðŸ“ Events: ${blockInfo.eventsCount}\n\nðŸ“Š This block processed ${blockInfo.extrinsicsCount} transaction${\n                blockInfo.extrinsicsCount === 1 ? '' : 's'\n            } and generated ${blockInfo.eventsCount} event${\n                blockInfo.eventsCount === 1 ? '' : 's'\n            }.`;\n\n            const result = {\n                status: 'success',\n                number: blockInfo.number,\n                hash: blockInfo.hash,\n                parentHash: blockInfo.parentHash,\n                stateRoot: blockInfo.stateRoot,\n                extrinsicsRoot: blockInfo.extrinsicsRoot,\n                timestamp: blockInfo.timestamp,\n                extrinsicsCount: blockInfo.extrinsicsCount,\n                eventsCount: blockInfo.eventsCount,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving block info:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving block info: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"What's the information for block 12345678?\",\n                    action: 'GET_BLOCK_INFO',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block 12345678 Information\\n\\nBasic Details:\\nâ€¢ Number: 12345678\\nâ€¢ Hash: 0x8d7c0cce1768da5c...\\nâ€¢ Parent: 0x557be0d61c75e187...\\nâ° Time: 2023-06-15 12:34:56 UTC\\n\\nMerkle Roots:\\nâ€¢ State Root: 0x7b8f01096c356d77...\\nâ€¢ Extrinsics Root: 0x8a65db1f6cc5a7e5...\\n\\nBlock Content:\\nâ€¢ ðŸ“‹ Extrinsics: 3\\nâ€¢ ðŸ“ Events: 8\\n\\nðŸ“Š This block processed 3 transactions and generated 8 events.',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Show me the details of block 0x8d7c0cce1768da5c1725def400ce1a337369cbba4c4844d6f9b8bab255c9bb07',\n                    action: 'GET_BLOCK_INFO',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block 12345678 Information\\n\\nBasic Details:\\nâ€¢ Number: 12345678\\nâ€¢ Hash: 0x8d7c0cce1768da5c...\\nâ€¢ Parent: 0x557be0d61c75e187...\\nâ° Time: 2023-06-15 12:34:56 UTC\\n\\nMerkle Roots:\\nâ€¢ State Root: 0x7b8f01096c356d77...\\nâ€¢ Extrinsics Root: 0x8a65db1f6cc5a7e5...\\n\\nBlock Content:\\nâ€¢ ðŸ“‹ Extrinsics: 3\\nâ€¢ ðŸ“ Events: 8\\n\\nðŸ“Š This block processed 3 transactions and generated 8 events.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetBlockEventsContent extends Content {\n    blockNumberOrHash: string;\n    filterModule?: string;\n    limit?: number;\n}\n\nexport interface BlockEvent {\n    index: number;\n    section: string;\n    method: string;\n    dataCount: number;\n    phase: string;\n    summary: string;\n}\n\ninterface EventData {\n    [key: string]: unknown;\n}\n\n// Use a more flexible approach for Polkadot Codec types\ninterface PolkadotEvent {\n    section: { toString(): string };\n    method: { toString(): string };\n    data: { toJSON(): EventData[] };\n}\n\ninterface PolkadotPhase {\n    isApplyExtrinsic?: boolean;\n    asApplyExtrinsic?: { toString(): string };\n    isFinalization?: boolean;\n    isInitialization?: boolean;\n    type?: string;\n}\n\n// Use unknown for the complex Polkadot API types, then type guard them\ninterface EventRecord {\n    event: unknown;\n    phase: unknown;\n}\n\nexport const blockEventsSchema = z.object({\n    blockNumberOrHash: z.string().min(1, 'Block number or hash is required'),\n    filterModule: z\n        .string()\n        .optional()\n        .nullable()\n        .transform((val) => (val === 'null' || val === null ? undefined : val)),\n    limit: z\n        .union([z.number(), z.string()])\n        .optional()\n        .nullable()\n        .transform((val) => {\n            if (val === 'null' || val === null || val === undefined) return undefined;\n            const num = typeof val === 'string' ? parseInt(val) : val;\n            return Number.isNaN(num) ? undefined : Math.min(Math.max(num, 1), 1000);\n        }),\n});\n\nexport const blockEventsTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  \n  Extract the block number or hash from the message. Optionally extract a module filter (like \"balances\", \"system\", \"staking\") and a limit for the number of events.\n  \n  IMPORTANT: \n  - For filterModule: use the actual module name if specified, or omit the field entirely if not mentioned\n  - For limit: use the actual number if specified, or omit the field entirely if not mentioned\n  - Do NOT use the string \"null\" - either include the field with a value or omit it entirely\n  \n  Example response:\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"12345678\",\n    \"filterModule\": \"balances\",\n    \"limit\": 50\n  }\n  \\`\\`\\`\n  or\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"0x1a2b3c4d5e6f...\"\n  }\n  \\`\\`\\`\n  or \n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"12345678\",\n    \"limit\": 10\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetBlockEventsDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<{ content: GetBlockEventsContent }> {\n    const currentState = state || (await runtime.composeState(message));\n\n    const context = composeContext({\n        state: currentState,\n        template: blockEventsTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: blockEventsSchema as z.ZodTypeAny,\n        modelClass: ModelClass.MEDIUM,\n    });\n\n    const blockEventsData = result.object as GetBlockEventsContent;\n\n    if (!blockEventsData || !blockEventsData.blockNumberOrHash) {\n        throw new Error('Failed to extract a valid block number or hash from the message');\n    }\n\n    return { content: blockEventsData };\n}\n\n// Helper function to create a readable summary for different event types\nfunction createEventSummary(section: string, method: string, data: EventData[]): string {\n    const eventKey = `${section}.${method}`;\n\n    switch (eventKey) {\n        case 'balances.Transfer':\n            if (data.length >= 3) {\n                return `${data[0]} â†’ ${data[1]} (${data[2]} units)`;\n            }\n            break;\n        case 'balances.Deposit':\n            if (data.length >= 2) {\n                return `${data[0]} (+${data[1]} units)`;\n            }\n            break;\n        case 'system.ExtrinsicSuccess':\n            return 'Extrinsic executed successfully';\n        case 'system.ExtrinsicFailed':\n            return 'Extrinsic failed';\n        case 'staking.Reward':\n            if (data.length >= 2) {\n                return `${data[0]} rewarded ${data[1]} units`;\n            }\n            break;\n        case 'democracy.Proposed':\n            return 'New proposal created';\n        case 'democracy.Voted':\n            return 'Vote cast';\n        case 'treasury.Deposit':\n            if (data.length >= 1) {\n                return `Treasury deposit: ${data[0]} units`;\n            }\n            break;\n        default:\n            // For unknown events, just show the count of data items\n            if (data.length === 0) {\n                return 'No data';\n            }\n            if (data.length === 1) {\n                return '1 data item';\n            }\n            return `${data.length} data items`;\n    }\n\n    return data.length === 0 ? 'No data' : `${data.length} data items`;\n}\n\nexport class GetBlockEventsAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getBlockEvents(params: {\n        blockNumberOrHash: string;\n        filterModule?: string;\n        limit?: number;\n    }): Promise<{\n        blockNumber: string;\n        blockHash: string;\n        totalEvents: number;\n        filteredEvents: number;\n        events: BlockEvent[];\n        filterApplied?: string;\n        limitApplied?: number;\n    }> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n\n            let blockHash: string;\n            let blockNumber: string;\n\n            if (params.blockNumberOrHash.startsWith('0x')) {\n                // This is a hash\n                blockHash = params.blockNumberOrHash;\n                const header = await api.rpc.chain.getHeader(blockHash);\n                blockNumber = header.number.toString();\n            } else {\n                // This is a block number\n                blockNumber = params.blockNumberOrHash;\n                blockHash = (await api.rpc.chain.getBlockHash(parseInt(blockNumber))).toString();\n            }\n\n            // Get events for the block - use unknown to handle Codec type\n            const eventsAtBlock = await api.query.system.events.at(blockHash);\n\n            // Convert Codec to array - use unknown first, then cast to iterable\n            const eventsArray = Array.from(eventsAtBlock as unknown as Iterable<EventRecord>);\n            let processedEvents: BlockEvent[] = eventsArray.map(\n                (eventRecord: EventRecord, index) => {\n                    // Type guard and extract event details\n                    const event = eventRecord.event as PolkadotEvent;\n                    const phase = eventRecord.phase as PolkadotPhase;\n\n                    // Extract event details using the codec methods\n                    const section = event.section.toString();\n                    const method = event.method.toString();\n                    const data = event.data.toJSON() as EventData[];\n\n                    // Determine phase description\n                    let phaseDesc = 'Unknown';\n                    try {\n                        if (phase.isApplyExtrinsic) {\n                            phaseDesc = `Extrinsic ${\n                                phase.asApplyExtrinsic?.toString() || 'Unknown'\n                            }`;\n                        } else if (phase.isFinalization) {\n                            phaseDesc = 'Finalization';\n                        } else if (phase.isInitialization) {\n                            phaseDesc = 'Initialization';\n                        } else {\n                            phaseDesc = phase.type || 'Unknown';\n                        }\n                    } catch {\n                        phaseDesc = 'Unknown';\n                    }\n\n                    // Create a readable summary instead of showing raw data\n                    const summary = createEventSummary(section, method, data);\n\n                    return {\n                        index,\n                        section,\n                        method,\n                        dataCount: data.length,\n                        phase: phaseDesc,\n                        summary,\n                    };\n                },\n            );\n\n            const totalEvents = processedEvents.length;\n\n            // Apply module filter if specified\n            if (params.filterModule) {\n                processedEvents = processedEvents.filter(\n                    (event) => event.section.toLowerCase() === params.filterModule?.toLowerCase(),\n                );\n            }\n\n            const filteredEvents = processedEvents.length;\n\n            // Apply limit if specified\n            if (params.limit && params.limit < processedEvents.length) {\n                processedEvents = processedEvents.slice(0, params.limit);\n            }\n\n            return {\n                blockNumber,\n                blockHash: blockHash.toString(),\n                totalEvents,\n                filteredEvents,\n                events: processedEvents,\n                filterApplied: params.filterModule,\n                limitApplied: params.limit,\n            };\n        } catch (error) {\n            elizaLogger.error(\n                `Error fetching events for block ${params.blockNumberOrHash}:`,\n                error,\n            );\n            throw new Error(`Failed to retrieve block events: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_BLOCK_EVENTS',\n    similes: ['VIEW_BLOCK_EVENTS', 'BLOCK_EVENTS', 'POLKADOT_EVENTS', 'GET_EVENTS'],\n    description:\n        'Retrieves all events that occurred in a specific Polkadot block, with optional filtering by module and limiting.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_BLOCK_EVENTS action...');\n\n        try {\n            const { content: getBlockEventsContent } = await buildGetBlockEventsDetails(\n                runtime,\n                message,\n                state,\n            );\n\n            elizaLogger.debug('getBlockEventsContent', getBlockEventsContent);\n\n            if (\n                !getBlockEventsContent ||\n                typeof getBlockEventsContent.blockNumberOrHash !== 'string'\n            ) {\n                elizaLogger.error('Failed to obtain a valid block number or hash.');\n                if (callback) {\n                    callback({\n                        text: \"I couldn't process your block events request. Please provide a valid block number or hash.\",\n                        content: { error: 'Invalid block number or hash format.' },\n                    });\n                }\n                return false;\n            }\n\n            const action = new GetBlockEventsAction(runtime);\n            const eventsInfo = await action.getBlockEvents({\n                blockNumberOrHash: getBlockEventsContent.blockNumberOrHash,\n                filterModule: getBlockEventsContent.filterModule,\n                limit: getBlockEventsContent.limit,\n            });\n\n            // Format events for display - cleaner formatting\n            const eventsDisplay = eventsInfo.events\n                .map((event, idx) => {\n                    return `${idx + 1}. ${event.section}.${event.method} (${event.phase})\\n   â””â”€ ${\n                        event.summary\n                    }`;\n                })\n                .join('\\n');\n\n            const showingText =\n                eventsInfo.events.length < eventsInfo.filteredEvents\n                    ? ` (showing first ${eventsInfo.events.length})`\n                    : '';\n\n            const filterText = eventsInfo.filterApplied\n                ? `\\nFilter: ${eventsInfo.filterApplied} module events only`\n                : '';\n\n            const moreEventsText =\n                eventsInfo.events.length < eventsInfo.filteredEvents\n                    ? `\\n\\nðŸ“‹ ${\n                          eventsInfo.filteredEvents - eventsInfo.events.length\n                      } more events available. Use a higher limit to see more.`\n                    : '';\n\n            const userMessageText = `\nðŸ“¦ Block Events for Block ${eventsInfo.blockNumber}\nHash: ${eventsInfo.blockHash.slice(0, 20)}...\n\nSummary:\nâ€¢ Total Events: ${eventsInfo.totalEvents}\nâ€¢ Filtered Events: ${eventsInfo.filteredEvents}${showingText}${filterText}\n\n${\n    eventsInfo.events.length > 0\n        ? `Events:\\n${eventsDisplay}${moreEventsText}`\n        : 'âŒ No events found with the applied filters.'\n}`;\n\n            const result = {\n                status: 'success',\n                blockNumber: eventsInfo.blockNumber,\n                blockHash: eventsInfo.blockHash,\n                totalEvents: eventsInfo.totalEvents,\n                filteredEvents: eventsInfo.filteredEvents,\n                events: eventsInfo.events,\n                filterApplied: eventsInfo.filterApplied,\n                limitApplied: eventsInfo.limitApplied,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving block events:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving block events: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'What events happened in block 12345678?',\n                    action: 'GET_BLOCK_EVENTS',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block Events for Block 12345678\\nHash: 0x8d7c0cce1768da5c...\\n\\nSummary:\\nâ€¢ Total Events: 8\\nâ€¢ Filtered Events: 8 (showing first 5)\\n\\nEvents:\\n1. system.ExtrinsicSuccess (Extrinsic 1)\\n   â””â”€ Extrinsic executed successfully\\n\\n2. balances.Transfer (Extrinsic 2)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY â†’ 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty (10000000000 units)\\n\\n3. system.ExtrinsicSuccess (Extrinsic 2)\\n   â””â”€ Extrinsic executed successfully\\n\\n4. treasury.Deposit (Finalization)\\n   â””â”€ Treasury deposit: 1000000000 units\\n\\n5. balances.Deposit (Finalization)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY (+500000000 units)\\n\\nðŸ“‹ 3 more events available. Use a higher limit to see more.',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Show me only the balances events from block 0x8d7c0cce1768da5c1725def400ce1a337369cbba4c4844d6f9b8bab255c9bb07',\n                    action: 'GET_BLOCK_EVENTS',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block Events for Block 12345678\\nHash: 0x8d7c0cce1768da5c...\\n\\nSummary:\\nâ€¢ Total Events: 8\\nâ€¢ Filtered Events: 3\\nFilter: balances module events only\\n\\nEvents:\\n1. balances.Transfer (Extrinsic 2)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY â†’ 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty (10000000000 units)\\n\\n2. balances.Deposit (Finalization)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY (+500000000 units)\\n\\n3. balances.Reserved (Finalization)\\n   â””â”€ 2 data items',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Get the first 3 events from block 12345678',\n                    action: 'GET_BLOCK_EVENTS',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block Events for Block 12345678\\nHash: 0x8d7c0cce1768da5c...\\n\\nSummary:\\nâ€¢ Total Events: 8\\nâ€¢ Filtered Events: 8 (showing first 3)\\n\\nEvents:\\n1. system.ExtrinsicSuccess (Extrinsic 1)\\n   â””â”€ Extrinsic executed successfully\\n\\n2. balances.Transfer (Extrinsic 2)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY â†’ 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty (10000000000 units)\\n\\n3. system.ExtrinsicSuccess (Extrinsic 2)\\n   â””â”€ Extrinsic executed successfully\\n\\nðŸ“‹ 5 more events available. Use a higher limit to see more.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetReferendaContent extends Content {\n    limit?: number;\n}\n\nexport interface ReferendumInfo {\n    id: number;\n    trackId: number;\n    trackName: string;\n    status: string;\n    proposalHash?: string;\n    submitted?: string;\n    submissionDeposit?: {\n        who: string;\n        amount: string;\n    };\n    decisionDeposit?: {\n        who: string;\n        amount: string;\n    };\n    deciding?: {\n        since: string;\n        confirming?: string;\n    };\n    tally?: {\n        ayes: string;\n        nays: string;\n        support: string;\n    };\n    alarm?: string;\n}\n\n// Define proper types for API responses\ninterface ReferendumApiResponse {\n    isSome: boolean;\n    unwrap: () => {\n        toJSON: () => ReferendumData;\n    };\n}\n\ninterface ReferendumData {\n    ongoing?: OngoingReferendum;\n    approved?: unknown;\n    rejected?: unknown;\n    cancelled?: unknown;\n    timedOut?: unknown;\n    killed?: unknown;\n}\n\ninterface OngoingReferendum {\n    track: number;\n    proposal?: {\n        lookup?: { hash: string };\n        inline?: string;\n    };\n    submitted?: number;\n    submissionDeposit?: {\n        who: string;\n        amount?: number;\n    };\n    decisionDeposit?: {\n        who: string;\n        amount?: number;\n    };\n    deciding?: {\n        since?: number;\n        confirming?: number;\n    };\n    tally?: {\n        ayes?: number;\n        nays?: number;\n        support?: number;\n    };\n    alarm?: number;\n}\n\nexport const referendaSchema = z.object({\n    limit: z\n        .union([z.number(), z.string()])\n        .optional()\n        .nullable()\n        .transform((val) => {\n            if (val === 'null' || val === null || val === undefined) return undefined;\n            const num = typeof val === 'string' ? parseInt(val) : val;\n            return Number.isNaN(num) ? undefined : Math.min(Math.max(num, 1), 50);\n        }),\n});\n\nexport const referendaTemplate = `Respond with a JSON markdown block containing only the extracted values.\n  \n  Extract the number of referenda the user wants to see from their message.\n  Look for numbers like \"show me 5 referenda\", \"get 10 proposals\", \"last 3 governance items\", etc.\n  \n  If no specific number is mentioned, omit the limit field to use the default.\n  Maximum limit is 50.\n  \n  Example responses:\n  \\`\\`\\`json\n  {\n    \"limit\": 10\n  }\n  \\`\\`\\`\n  or\n  \\`\\`\\`json\n  {}\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetReferendaDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<{ content: GetReferendaContent }> {\n    const currentState = state || (await runtime.composeState(message));\n\n    const context = composeContext({\n        state: currentState,\n        template: referendaTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: referendaSchema as z.ZodTypeAny,\n        modelClass: ModelClass.MEDIUM,\n    });\n\n    const referendaData = result.object as GetReferendaContent;\n\n    return { content: referendaData };\n}\n\n// Helper function to get track name from track ID\nfunction getTrackName(trackId: number): string {\n    if (trackId === -1) {\n        return 'unknown';\n    }\n\n    const trackNames: { [key: number]: string } = {\n        0: 'root',\n        1: 'whitelisted_caller',\n        10: 'staking_admin',\n        11: 'treasurer',\n        12: 'lease_admin',\n        13: 'fellowship_admin',\n        14: 'general_admin',\n        15: 'auction_admin',\n        20: 'referendum_canceller',\n        21: 'referendum_killer',\n        30: 'small_tipper',\n        31: 'big_tipper',\n        32: 'small_spender',\n        33: 'medium_spender',\n        34: 'big_spender',\n    };\n\n    return trackNames[trackId] || `track_${trackId}`;\n}\n\n// Helper function to format referendum status\nfunction formatReferendumStatus(referendumInfo: ReferendumData): string {\n    if (referendumInfo.ongoing) {\n        return 'ongoing';\n    }\n    if (referendumInfo.approved) {\n        return 'approved';\n    }\n    if (referendumInfo.rejected) {\n        return 'rejected';\n    }\n    if (referendumInfo.cancelled) {\n        return 'cancelled';\n    }\n    if (referendumInfo.timedOut) {\n        return 'timedout';\n    }\n    if (referendumInfo.killed) {\n        return 'killed';\n    }\n    return 'unknown';\n}\n\n// Helper function to format large numbers\nfunction formatTokenAmount(amount: string, decimals = 10, symbol = 'DOT'): string {\n    const value = BigInt(amount);\n    const divisor = BigInt(10 ** decimals);\n    const quotient = value / divisor;\n    const remainder = value % divisor;\n\n    if (remainder === BigInt(0)) {\n        return `${quotient} ${symbol}`;\n    }\n    const decimal = remainder.toString().padStart(decimals, '0').replace(/0+$/, '');\n    return `${quotient}.${decimal} ${symbol}`;\n}\n\nexport class GetReferendaAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getReferenda(limit = 10): Promise<{\n        totalCount: number;\n        returnedCount: number;\n        referenda: ReferendumInfo[];\n    }> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n\n            // Get the total referendum count\n            const referendumCount = await api.query.referenda.referendumCount();\n            const totalCount = parseInt(referendumCount.toString());\n\n            const referenda: ReferendumInfo[] = [];\n            const maxLimit = Math.min(limit, 50); // Cap at 50\n\n            // Fetch referendum info for recent referenda (working backwards from latest)\n            for (let i = totalCount - 1; i >= 0 && referenda.length < maxLimit; i--) {\n                try {\n                    const referendumInfo = await api.query.referenda.referendumInfoFor(i);\n\n                    const apiResponse = referendumInfo as unknown as ReferendumApiResponse;\n                    if (apiResponse.isSome) {\n                        const info = apiResponse.unwrap().toJSON();\n\n                        // Extract track ID\n                        let trackId: number;\n                        if (\n                            info.ongoing &&\n                            typeof info.ongoing === 'object' &&\n                            info.ongoing.track !== undefined\n                        ) {\n                            trackId = info.ongoing.track;\n                        } else {\n                            // For completed referenda, track info is not preserved, in the future we could snapshot the api to get histroical\n                            trackId = -1; // Use -1 to indicate unknown track\n                        }\n\n                        const status = formatReferendumStatus(info);\n\n                        // Extract referendum data\n                        const referendum: ReferendumInfo = {\n                            id: i,\n                            trackId,\n                            trackName: getTrackName(trackId),\n                            status,\n                        };\n\n                        // Add additional details for ongoing referenda\n                        if (info.ongoing) {\n                            referendum.proposalHash =\n                                info.ongoing.proposal?.lookup?.hash ||\n                                info.ongoing.proposal?.inline ||\n                                'unknown';\n                            referendum.submitted = info.ongoing.submitted?.toString();\n\n                            if (info.ongoing.submissionDeposit) {\n                                referendum.submissionDeposit = {\n                                    who: info.ongoing.submissionDeposit.who,\n                                    amount:\n                                        info.ongoing.submissionDeposit.amount?.toString() || '0',\n                                };\n                            }\n\n                            if (info.ongoing.decisionDeposit) {\n                                referendum.decisionDeposit = {\n                                    who: info.ongoing.decisionDeposit.who,\n                                    amount: info.ongoing.decisionDeposit.amount?.toString() || '0',\n                                };\n                            }\n\n                            if (info.ongoing.deciding) {\n                                referendum.deciding = {\n                                    since: info.ongoing.deciding.since?.toString(),\n                                    confirming: info.ongoing.deciding.confirming?.toString(),\n                                };\n                            }\n\n                            if (info.ongoing.tally) {\n                                referendum.tally = {\n                                    ayes: info.ongoing.tally.ayes?.toString() || '0',\n                                    nays: info.ongoing.tally.nays?.toString() || '0',\n                                    support: info.ongoing.tally.support?.toString() || '0',\n                                };\n                            }\n\n                            if (info.ongoing.alarm) {\n                                referendum.alarm = info.ongoing.alarm.toString();\n                            }\n                        }\n\n                        referenda.push(referendum);\n                    }\n                } catch (error) {\n                    // Skip referenda that can't be fetched\n                    elizaLogger.debug(`Skipping referendum ${i}: ${(error as Error).message}`);\n                }\n            }\n\n            return {\n                totalCount,\n                returnedCount: referenda.length,\n                referenda,\n            };\n        } catch (error) {\n            elizaLogger.error('Error fetching referenda:', error);\n            throw new Error(`Failed to retrieve referenda: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_REFERENDA',\n    similes: [\n        'VIEW_REFERENDA',\n        'POLKADOT_REFERENDA',\n        'GET_GOVERNANCE_REFERENDA',\n        'GOVERNANCE_PROPOSALS',\n        'VIEW_PROPOSALS',\n        'SHOW_REFERENDA',\n    ],\n    description:\n        \"Retrieves recent governance referenda from Polkadot's OpenGov system. Shows referendum details including track, status, voting results, and deposits.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_REFERENDA action...');\n\n        try {\n            const { content: getReferendaContent } = await buildGetReferendaDetails(\n                runtime,\n                message,\n                state,\n            );\n\n            elizaLogger.debug('getReferendaContent', getReferendaContent);\n\n            const action = new GetReferendaAction(runtime);\n            const referendaInfo = await action.getReferenda(getReferendaContent.limit || 10);\n\n            // Format referenda for display\n            const referendaDisplay = referendaInfo.referenda\n                .map((ref, idx) => {\n                    let details = `${idx + 1}. Referendum ${ref.id} (${ref.trackName})\n   Status: ${ref.status.toUpperCase()}`;\n\n                    if (ref.tally) {\n                        const ayes = formatTokenAmount(ref.tally.ayes, 3);\n                        const nays = formatTokenAmount(ref.tally.nays, 3);\n                        details += `\n   Votes: ${ayes} AYE, ${nays} NAY`;\n                    }\n\n                    if (ref.deciding) {\n                        details += `\n   Deciding since block: ${ref.deciding.since}`;\n                        if (ref.deciding.confirming) {\n                            details += ` (confirming since: ${ref.deciding.confirming})`;\n                        }\n                    }\n\n                    if (ref.submissionDeposit) {\n                        const deposit = formatTokenAmount(ref.submissionDeposit.amount, 3);\n                        details += `\n   Deposit: ${deposit} by ${ref.submissionDeposit.who}`;\n                    }\n\n                    return details;\n                })\n                .join('\\n\\n');\n\n            const userMessageText = `\nðŸ›ï¸ Polkadot Governance Referenda\n\nSummary:\nâ€¢ Total Referenda: ${referendaInfo.totalCount}\nâ€¢ Showing: ${referendaInfo.returnedCount}\n\n${\n    referendaInfo.referenda.length > 0\n        ? `Recent Referenda:\\n${referendaDisplay}`\n        : 'âŒ No referenda found.'\n}\n\nðŸ’¡ Note: Completed referenda show \"unknown\" track as this information is not preserved on-chain.`;\n\n            const result = {\n                status: 'success',\n                totalCount: referendaInfo.totalCount,\n                returnedCount: referendaInfo.returnedCount,\n                referenda: referendaInfo.referenda,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving referenda:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving referenda: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'What are the current governance referenda?',\n                    action: 'GET_REFERENDA',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Here's a list of current ongoing referenda...\",\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Show me the last 5 governance proposals',\n                    action: 'GET_REFERENDA',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Here's a list of the 5 latest referenda...\",\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Get me 20 referenda',\n                    action: 'GET_REFERENDA',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"Here's a list of the last 20 referenda...\",\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { elizaLogger, ModelClass, generateObject, composeContext } from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetReferendumDetailsContent extends Content {\n    referendumId: number;\n}\n\nexport interface DetailedReferendumInfo {\n    id: number;\n    trackId: number;\n    trackName: string;\n    status: string;\n    proposalHash?: string;\n    proposalLength?: number;\n    enactmentDelay?: number;\n    submitted?: string;\n    submissionDeposit?: {\n        who: string;\n        amount: string;\n        formattedAmount: string;\n    };\n    decisionDeposit?: {\n        who: string;\n        amount: string;\n        formattedAmount: string;\n    };\n    deciding?: {\n        since: string;\n        confirming?: string;\n    };\n    tally?: {\n        ayes: string;\n        nays: string;\n        support: string;\n        formattedAyes: string;\n        formattedNays: string;\n        formattedSupport: string;\n    };\n    inQueue?: boolean;\n    alarm?: string[];\n    completionBlock?: string;\n    origin?: string;\n}\n\ninterface ReferendumInfoData {\n    ongoing?: {\n        track: number;\n        proposal?: {\n            lookup?: {\n                hash: string;\n                len?: number;\n            };\n            inline?: string;\n        };\n        origin?: {\n            origins: string;\n        };\n        enactment?: {\n            after: number;\n        };\n        submitted?: string | number;\n        submissionDeposit?: {\n            who: string;\n            amount?: string | number;\n        };\n        decisionDeposit?: {\n            who: string;\n            amount?: string | number;\n        };\n        deciding?: {\n            since?: string | number;\n            confirming?: string | number;\n        };\n        tally?: {\n            ayes?: string | number;\n            nays?: string | number;\n            support?: string | number;\n        };\n        inQueue?: boolean;\n        alarm?: string | number | (string | number)[];\n    };\n    approved?: string[] | { since: string };\n    rejected?: string[];\n    cancelled?: string[];\n    timedOut?: string[];\n    killed?: string[];\n}\n\ninterface ReferendumApiResponse {\n    isSome: boolean;\n    unwrap: () => {\n        toJSON: () => ReferendumInfoData;\n    };\n}\n\nexport const referendumDetailsSchema = z.object({\n    referendumId: z.union([z.number(), z.string()]).transform((val) => {\n        const num = typeof val === 'string' ? parseInt(val) : val;\n        if (Number.isNaN(num) || num < 0) {\n            throw new Error('Invalid referendum ID');\n        }\n        return num;\n    }),\n});\n\nexport const referendumDetailsTemplate = `Respond with a JSON markdown block containing only the extracted referendum ID.\n  \n  Extract the referendum ID number from the user's message. Look for patterns like:\n  - \"referendum 123\"\n  - \"proposal 456\"\n  - \"ref 789\"\n  - \"referendum #42\"\n  - \"show me referendum 100\"\n  - \"details for 200\"\n  - just a plain number if the context is about referenda\n  \n  The referendum ID must be a valid positive number.\n  \n  Example responses:\n  \\`\\`\\`json\n  {\n    \"referendumId\": 123\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the referendum ID.`;\n\nexport async function buildGetReferendumDetailsRequest(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<{ content: GetReferendumDetailsContent }> {\n    const currentState = state || (await runtime.composeState(message));\n\n    const context = composeContext({\n        state: currentState,\n        template: referendumDetailsTemplate,\n    });\n\n    const result = await generateObject({\n        runtime,\n        context,\n        schema: referendumDetailsSchema as z.ZodTypeAny,\n        modelClass: ModelClass.MEDIUM,\n    });\n\n    const detailsData = result.object as GetReferendumDetailsContent;\n\n    return { content: detailsData };\n}\n\n// Helper function to get track name from track ID\nfunction getTrackName(trackId: number): string {\n    if (trackId === -1) {\n        return 'unknown';\n    }\n\n    const trackNames: { [key: number]: string } = {\n        0: 'root',\n        1: 'whitelisted_caller',\n        10: 'staking_admin',\n        11: 'treasurer',\n        12: 'lease_admin',\n        13: 'fellowship_admin',\n        14: 'general_admin',\n        15: 'auction_admin',\n        20: 'referendum_canceller',\n        21: 'referendum_killer',\n        30: 'small_tipper',\n        31: 'big_tipper',\n        32: 'small_spender',\n        33: 'medium_spender',\n        34: 'big_spender',\n    };\n\n    return trackNames[trackId] || `track_${trackId}`;\n}\n\n// Helper function to format referendum status\nfunction formatReferendumStatus(referendumInfo: ReferendumInfoData): string {\n    if (referendumInfo.ongoing) {\n        return 'ongoing';\n    }\n    if (referendumInfo.approved) {\n        return 'approved';\n    }\n    if (referendumInfo.rejected) {\n        return 'rejected';\n    }\n    if (referendumInfo.cancelled) {\n        return 'cancelled';\n    }\n    if (referendumInfo.timedOut) {\n        return 'timedout';\n    }\n    if (referendumInfo.killed) {\n        return 'killed';\n    }\n    return 'unknown';\n}\n\n// Helper function to format large numbers\nfunction formatTokenAmount(amount: string, decimals = 10, symbol = 'DOT'): string {\n    const value = BigInt(amount);\n    const divisor = BigInt(10 ** decimals);\n    const quotient = value / divisor;\n    const remainder = value % divisor;\n\n    if (remainder === BigInt(0)) {\n        return `${quotient} ${symbol}`;\n    }\n    const decimal = remainder.toString().padStart(decimals, '0').replace(/0+$/, '');\n    return `${quotient}.${decimal} ${symbol}`;\n}\n\nexport class GetReferendumDetailsAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getReferendumDetails(referendumId: number): Promise<DetailedReferendumInfo> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n\n            // Get the total referendum count to validate the ID\n            const referendumCount = await api.query.referenda.referendumCount();\n            const totalCount = parseInt(referendumCount.toString());\n\n            if (referendumId >= totalCount) {\n                throw new Error(\n                    `Referendum ${referendumId} does not exist. Latest referendum is ${\n                        totalCount - 1\n                    }.`,\n                );\n            }\n\n            // Fetch the specific referendum\n            const referendumInfo = await api.query.referenda.referendumInfoFor(referendumId);\n\n            const typedReferendumInfo = referendumInfo as unknown as ReferendumApiResponse;\n\n            if (!typedReferendumInfo.isSome) {\n                throw new Error(`Referendum ${referendumId} not found or has no data.`);\n            }\n\n            const info = typedReferendumInfo.unwrap().toJSON();\n            elizaLogger.info(info);\n\n            // Extract track ID\n            let trackId: number;\n            if (\n                info.ongoing &&\n                typeof info.ongoing === 'object' &&\n                info.ongoing.track !== undefined\n            ) {\n                trackId = info.ongoing.track;\n            } else {\n                // For completed referenda, track info is not preserved\n                trackId = -1;\n            }\n\n            const status = formatReferendumStatus(info);\n\n            // Build detailed referendum info\n            const referendum: DetailedReferendumInfo = {\n                id: referendumId,\n                trackId,\n                trackName: getTrackName(trackId),\n                status,\n            };\n\n            // Extract common details for ongoing referenda\n            if (info.ongoing) {\n                // Proposal information\n                referendum.proposalHash =\n                    info.ongoing.proposal?.lookup?.hash ||\n                    info.ongoing.proposal?.inline ||\n                    'unknown';\n                referendum.proposalLength = info.ongoing.proposal?.lookup?.len;\n\n                // Origin information\n                referendum.origin = info.ongoing.origin?.origins || 'unknown';\n\n                // Enactment delay\n                referendum.enactmentDelay = info.ongoing.enactment?.after;\n\n                // Submission details\n                referendum.submitted = info.ongoing.submitted?.toString();\n\n                // Deposits\n                if (info.ongoing.submissionDeposit) {\n                    referendum.submissionDeposit = {\n                        who: info.ongoing.submissionDeposit.who,\n                        amount: info.ongoing.submissionDeposit.amount?.toString() || '0',\n                        formattedAmount: formatTokenAmount(\n                            info.ongoing.submissionDeposit.amount?.toString() || '0',\n                        ),\n                    };\n                }\n\n                if (info.ongoing.decisionDeposit) {\n                    referendum.decisionDeposit = {\n                        who: info.ongoing.decisionDeposit.who,\n                        amount: info.ongoing.decisionDeposit.amount?.toString() || '0',\n                        formattedAmount: formatTokenAmount(\n                            info.ongoing.decisionDeposit.amount?.toString() || '0',\n                        ),\n                    };\n                }\n\n                // Deciding phase\n                if (info.ongoing.deciding) {\n                    referendum.deciding = {\n                        since: info.ongoing.deciding.since?.toString(),\n                        confirming: info.ongoing.deciding.confirming?.toString(),\n                    };\n                }\n\n                // Tally\n                if (info.ongoing.tally) {\n                    referendum.tally = {\n                        ayes: info.ongoing.tally.ayes?.toString() || '0',\n                        nays: info.ongoing.tally.nays?.toString() || '0',\n                        support: info.ongoing.tally.support?.toString() || '0',\n                        formattedAyes: formatTokenAmount(\n                            info.ongoing.tally.ayes?.toString() || '0',\n                        ),\n                        formattedNays: formatTokenAmount(\n                            info.ongoing.tally.nays?.toString() || '0',\n                        ),\n                        formattedSupport: formatTokenAmount(\n                            info.ongoing.tally.support?.toString() || '0',\n                        ),\n                    };\n                }\n\n                // Queue status\n                referendum.inQueue = info.ongoing.inQueue || false;\n\n                // Alarm\n                if (info.ongoing.alarm) {\n                    referendum.alarm = Array.isArray(info.ongoing.alarm)\n                        ? info.ongoing.alarm.map((a) => a.toString())\n                        : [info.ongoing.alarm.toString()];\n                }\n            } else {\n                // For completed referenda, extract completion block if available\n                if (info.approved && Array.isArray(info.approved) && info.approved[0]) {\n                    referendum.completionBlock = info.approved[0].toString();\n                } else if (info.rejected && Array.isArray(info.rejected) && info.rejected[0]) {\n                    referendum.completionBlock = info.rejected[0].toString();\n                } else if (info.cancelled && Array.isArray(info.cancelled) && info.cancelled[0]) {\n                    referendum.completionBlock = info.cancelled[0].toString();\n                } else if (info.timedOut && Array.isArray(info.timedOut) && info.timedOut[0]) {\n                    referendum.completionBlock = info.timedOut[0].toString();\n                } else if (info.killed && Array.isArray(info.killed) && info.killed[0]) {\n                    referendum.completionBlock = info.killed[0].toString();\n                }\n            }\n\n            return referendum;\n        } catch (error) {\n            elizaLogger.error(`Error fetching referendum ${referendumId}:`, error);\n            throw new Error(`Failed to retrieve referendum ${referendumId}: ${error.message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_REFERENDUM_DETAILS',\n    similes: [\n        'VIEW_REFERENDUM_DETAILS',\n        'REFERENDUM_INFO',\n        'GET_REFERENDUM_INFO',\n        'SHOW_REFERENDUM',\n        'REFERENDUM_DETAILS',\n        'PROPOSAL_DETAILS',\n    ],\n    description:\n        \"Retrieves detailed information about a specific governance referendum from Polkadot's OpenGov system by referendum ID.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_REFERENDUM_DETAILS action...');\n\n        try {\n            const { content: detailsContent } = await buildGetReferendumDetailsRequest(\n                runtime,\n                message,\n                state,\n            );\n\n            elizaLogger.debug('detailsContent', detailsContent);\n\n            const action = new GetReferendumDetailsAction(runtime);\n            const referendum = await action.getReferendumDetails(detailsContent.referendumId);\n\n            // Format details for display\n            let userMessageText = `\nðŸ›ï¸ Referendum ${referendum.id} Details\n\nOverview:\nâ€¢ Track: ${referendum.trackName} (${\n                referendum.trackId === -1 ? 'track info not preserved' : `ID: ${referendum.trackId}`\n            })\nâ€¢ Status: ${referendum.status.toUpperCase()}`;\n\n            if (referendum.origin) {\n                userMessageText += `\nâ€¢ Origin: ${referendum.origin}`;\n            }\n\n            if (referendum.completionBlock) {\n                userMessageText += `\nâ€¢ Completed at block: ${referendum.completionBlock}`;\n            }\n\n            if (referendum.proposalHash) {\n                userMessageText += `\n\nProposal:\nâ€¢ Hash: ${referendum.proposalHash}`;\n\n                if (referendum.proposalLength) {\n                    userMessageText += `\nâ€¢ Length: ${referendum.proposalLength} bytes`;\n                }\n\n                if (referendum.enactmentDelay) {\n                    userMessageText += `\nâ€¢ Enactment delay: ${referendum.enactmentDelay} blocks`;\n                }\n            }\n\n            if (referendum.submitted) {\n                userMessageText += `\n\nTimeline:\nâ€¢ Submitted at block: ${referendum.submitted}`;\n\n                if (referendum.deciding) {\n                    userMessageText += `\nâ€¢ Deciding since block: ${referendum.deciding.since}`;\n                    if (referendum.deciding.confirming) {\n                        userMessageText += `\nâ€¢ Confirming since block: ${referendum.deciding.confirming}`;\n                    }\n                }\n            }\n\n            if (referendum.tally) {\n                const ayesPercent =\n                    referendum.tally.ayes !== '0' && referendum.tally.nays !== '0'\n                        ? (\n                              (BigInt(referendum.tally.ayes) * BigInt(100)) /\n                              (BigInt(referendum.tally.ayes) + BigInt(referendum.tally.nays))\n                          ).toString()\n                        : 'N/A';\n\n                userMessageText += `\n\nðŸ—³ï¸ Voting Results:\nâ€¢ Ayes: ${referendum.tally.formattedAyes}`;\n\n                if (ayesPercent !== 'N/A') {\n                    userMessageText += ` (${ayesPercent}%)`;\n                }\n\n                userMessageText += `\nâ€¢ Nays: ${referendum.tally.formattedNays}\nâ€¢ Support: ${referendum.tally.formattedSupport}`;\n            }\n\n            if (referendum.submissionDeposit || referendum.decisionDeposit) {\n                userMessageText += `\n\nDeposits:`;\n\n                if (referendum.submissionDeposit) {\n                    userMessageText += `\nâ€¢ Submission: ${referendum.submissionDeposit.formattedAmount} by ${referendum.submissionDeposit.who}`;\n                }\n\n                if (referendum.decisionDeposit) {\n                    userMessageText += `\nâ€¢ Decision: ${referendum.decisionDeposit.formattedAmount} by ${referendum.decisionDeposit.who}`;\n                }\n            }\n\n            if (referendum.alarm) {\n                userMessageText += `\n\nâ° Alarm: Set for block ${referendum.alarm[0]}`;\n            }\n\n            if (referendum.inQueue !== undefined) {\n                userMessageText += `\n\nQueue Status: ${referendum.inQueue ? 'In queue' : 'Not in queue'}`;\n            }\n\n            const result = {\n                status: 'success',\n                referendum,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving referendum details:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving referendum details: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Show me details for referendum 586',\n                    action: 'GET_REFERENDUM_DETAILS',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ›ï¸ Referendum 586 Details\\n\\nOverview:\\nâ€¢ Track: medium_spender (ID: 33)\\nâ€¢ Status: ONGOING\\nâ€¢ Origin: MediumSpender\\n\\nProposal:\\nâ€¢ Hash: 0xad649d315fe4c18ce3f9b9c09c698c0c860508cb3bcccdbce5adede355a26850\\nâ€¢ Length: 60 bytes\\nâ€¢ Enactment delay: 100 blocks\\n\\nTimeline:\\nâ€¢ Submitted at block: 26316166\\nâ€¢ Deciding since block: 26318566\\n\\nðŸ—³ï¸ Voting Results:\\nâ€¢ Ayes: 105.0 DOT (100%)\\nâ€¢ Nays: 0 DOT\\nâ€¢ Support: 35.0 DOT\\n\\nDeposits:\\nâ€¢ Submission: 1.0 DOT by 136byv85...n5Rz\\nâ€¢ Decision: 200.0 DOT by 136byv85...n5Rz\\n\\nâ° Alarm: Set for block 26721700\\n\\nQueue Status: Not in queue',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'Get referendum 500 info',\n                    action: 'GET_REFERENDUM_DETAILS',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ›ï¸ Referendum 500 Details\\n\\nOverview:\\nâ€¢ Track: unknown (track info not preserved)\\nâ€¢ Status: APPROVED\\nâ€¢ Completed at block: 24567890\\n\\nðŸ’¡ Note: This referendum has been completed. Detailed voting information and track data are not preserved on-chain for completed referenda.',\n                },\n            },\n        ],\n        [\n            {\n                user: '{{user1}}',\n                content: {\n                    text: \"What's the status of proposal 123?\",\n                    action: 'GET_REFERENDUM_DETAILS',\n                },\n            },\n            {\n                user: '{{user1}}',\n                content: {\n                    text: 'ðŸ›ï¸ Referendum 123 Details\\n\\nOverview:\\nâ€¢ Track: treasurer (ID: 11)\\nâ€¢ Status: ONGOING\\nâ€¢ Origin: Treasurer\\n\\nProposal:\\nâ€¢ Hash: 0x1234567890abcdef1234567890abcdef12345678\\nâ€¢ Length: 45 bytes\\nâ€¢ Enactment delay: 50 blocks\\n\\nTimeline:\\nâ€¢ Submitted at block: 26200000\\nâ€¢ Deciding since block: 26202000\\n\\nðŸ—³ï¸ Voting Results:\\nâ€¢ Ayes: 5,432.1 DOT (92%)\\nâ€¢ Nays: 456.7 DOT\\nâ€¢ Support: 1,234.5 DOT\\n\\nDeposits:\\nâ€¢ Submission: 10.0 DOT by 5GrwvaEF...Xb26\\nâ€¢ Decision: 100.0 DOT by 5GrwvaEF...Xb26\\n\\nQueue Status: Not in queue',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, Provider, State } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\nimport { PolkadotApiService } from '../services/api-service';\n\ninterface ChainInfo {\n    name: string;\n    nodeName: string;\n    nodeVersion: string;\n    properties: {\n        tokenSymbol: string;\n        tokenDecimals: number;\n    };\n    health: {\n        peers: number;\n        isSyncing: boolean;\n        shouldHavePeers: boolean;\n    };\n    blocks: {\n        best: string;\n        finalized: string;\n    };\n    timestamp: number;\n}\n\n// Define types for API responses to avoid using any\ninterface PolkadotChainProperties {\n    tokenSymbol: {\n        unwrap: () => Array<{ toString: () => string }>;\n    };\n    tokenDecimals: {\n        unwrap: () => Array<{ toNumber: () => number }>;\n    };\n}\n\ninterface PolkadotHealth {\n    peers: { toNumber: () => number };\n    isSyncing: { valueOf: () => boolean };\n    shouldHavePeers: { valueOf: () => boolean };\n}\n\ninterface PolkadotCodec {\n    toString: () => string;\n    toJSON: () => unknown[];\n    toNumber?: () => number;\n}\n\nclass ChainDataService {\n    private apiService: PolkadotApiService;\n\n    public async initialize(runtime: IAgentRuntime): Promise<void> {\n        this.apiService = await PolkadotApiService.start(runtime);\n    }\n\n    public async getChainInfo(): Promise<ChainInfo> {\n        const api = await this.apiService.getConnection();\n\n        const [chain, nodeName, nodeVersion, properties, health, bestNumber, finalizedNumber] =\n            await Promise.all([\n                api.rpc.system.chain(),\n                api.rpc.system.name(),\n                api.rpc.system.version(),\n                api.rpc.system.properties(),\n                api.rpc.system.health(),\n                api.derive.chain.bestNumber(),\n                api.derive.chain.bestNumberFinalized(),\n            ]);\n\n        // Type the properties response properly\n        const typedProperties = properties as unknown as PolkadotChainProperties;\n        const typedHealth = health as unknown as PolkadotHealth;\n\n        const chainInfo: ChainInfo = {\n            name: chain.toString(),\n            nodeName: nodeName.toString(),\n            nodeVersion: nodeVersion.toString(),\n            properties: {\n                tokenSymbol: typedProperties.tokenSymbol.unwrap()[0].toString(),\n                tokenDecimals: typedProperties.tokenDecimals.unwrap()[0].toNumber(),\n            },\n            health: {\n                peers: typedHealth.peers.toNumber(),\n                isSyncing: typedHealth.isSyncing.valueOf(),\n                shouldHavePeers: typedHealth.shouldHavePeers.valueOf(),\n            },\n            blocks: {\n                best: bestNumber.toString(),\n                finalized: finalizedNumber.toString(),\n            },\n            timestamp: Date.now(),\n        };\n\n        return chainInfo;\n    }\n\n    public async getValidatorCount(): Promise<number> {\n        const api = await this.apiService.getConnection();\n        let count = 0;\n\n        try {\n            // Convert validators to array first\n            const validators = await api.query.session.validators();\n            const validatorsCodec = validators as unknown as PolkadotCodec;\n            const validatorsArray = validatorsCodec.toJSON() as unknown[];\n            count = Array.isArray(validatorsArray) ? validatorsArray.length : 0;\n        } catch (_error) {\n            try {\n                // Convert validator count to number\n                const validatorCount = await api.query.staking.validatorCount();\n                // Use toString and parseInt to avoid toNumber type errors\n                count = parseInt(validatorCount.toString());\n            } catch (innerError) {\n                const message =\n                    innerError instanceof Error ? innerError.message : String(innerError);\n                elizaLogger.error(`Error fetching validator count: ${message}`);\n            }\n        }\n\n        return count;\n    }\n\n    public async getParachainCount(): Promise<number> {\n        const api = await this.apiService.getConnection();\n        let count = 0;\n\n        try {\n            if (api.query.paras?.parachains) {\n                const parachains = await api.query.paras.parachains();\n                // Convert to array first with proper typing\n                const parachainsCodec = parachains as unknown as PolkadotCodec;\n                const parachainsArray = parachainsCodec.toJSON() as unknown[];\n                count = Array.isArray(parachainsArray) ? parachainsArray.length : 0;\n            }\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`Error fetching parachain count: ${message}`);\n        }\n\n        return count;\n    }\n\n    public formatChainInfo(chainInfo: ChainInfo): string {\n        const timeSinceUpdate = Math.floor((Date.now() - chainInfo.timestamp) / 1000);\n\n        return `Polkadot Network Status (updated ${timeSinceUpdate}s ago):\n- Network: ${chainInfo.name}\n- Connected: ${chainInfo.health.peers > 0 ? 'Yes' : 'No'} (${chainInfo.health.peers} peers)\n- Synced: ${!chainInfo.health.isSyncing ? 'Yes' : 'No'}\n- Latest Block: #${chainInfo.blocks.best} (finalized: #${chainInfo.blocks.finalized})\n- Native Token: ${chainInfo.properties.tokenSymbol}`;\n    }\n}\n\nexport const networkDataProvider: Provider = {\n    async get(_runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<string | null> {\n        try {\n            const chainDataService = new ChainDataService();\n            await chainDataService.initialize(_runtime);\n\n            const chainInfo = await chainDataService.getChainInfo();\n\n            const [validatorCount, parachainCount] = await Promise.all([\n                chainDataService.getValidatorCount(),\n                chainDataService.getParachainCount(),\n            ]);\n\n            let output = chainDataService.formatChainInfo(chainInfo);\n\n            if (validatorCount > 0) {\n                output += `\\nâ€¢ Active Validators: ${validatorCount}`;\n            }\n\n            if (parachainCount > 0) {\n                output += `\\nâ€¢ Connected Parachains: ${parachainCount}`;\n            }\n\n            elizaLogger.info('Network Data Provider output generated', output);\n            return output;\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`Error in Network Data Provider: ${message}`);\n\n            return 'Network Data Provider: Unable to retrieve current network status.';\n        }\n    },\n};\n\nexport default networkDataProvider;\n","import type { Plugin } from '@elizaos/core';\nimport createWalletAction from './actions/createWallet.ts';\nimport ejectWalletAction from './actions/ejectWallet.ts';\nimport signMessageAction from './actions/signMessage.ts';\nimport loadWalletAction from './actions/loadWallet.ts';\nimport validateSignatureAction from './actions/validateSignature.ts';\nimport getBalanceAction from './actions/getBalance.ts';\nimport getBlockInfoAction from './actions/getBlockInfo.ts';\nimport getBlockEventsAction from './actions/getBlockEvents.ts';\nimport getReferendaAction from './actions/getReferenda.ts';\nimport getReferendumDetailsAction from './actions/getReferendumDetails.ts';\nimport { WalletProvider, nativeWalletProvider } from './providers/wallet.ts';\nimport networkDataProvider from './providers/networkData.ts';\n\nexport {\n    WalletProvider,\n    createWalletAction as CreatePolkadotWallet,\n    ejectWalletAction as EjectPolkadotWallet,\n    signMessageAction as SignPolkadotMessage,\n    loadWalletAction as LoadPolkadotWallet,\n    getBalanceAction as GetBalance,\n    getBlockInfoAction as GetBlockInfo,\n    getBlockEventsAction as GetBlockEvents,\n    getReferendaAction as GetReferenda,\n    getReferendumDetailsAction as GetReferendumDetails,\n    validateSignatureAction as ValidateSignature,\n};\n\nexport const polkadotPlugin: Plugin = {\n    name: 'polkadot',\n    description: 'Polkadot Plugin for Eliza',\n    actions: [\n        createWalletAction,\n        ejectWalletAction,\n        signMessageAction,\n        loadWalletAction,\n        getBalanceAction,\n        getBlockInfoAction,\n        getBlockEventsAction,\n        getReferendaAction,\n        getReferendumDetailsAction,\n        validateSignatureAction,\n    ],\n    evaluators: [],\n    providers: [nativeWalletProvider, networkDataProvider],\n};\n\nexport default polkadotPlugin;\n"],"mappings":"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","names":["elizaLogger","elizaLogger","elizaLogger","elizaLogger","z","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","composeContext","generateObject","ModelClass","elizaLogger","result","elizaLogger","ModelClass","generateObject","composeContext","stringToU8a","u8aToHex","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","stringToU8a","hexToU8a","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","elizaLogger","elizaLogger","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","z","composeContext","generateObject","ModelClass","elizaLogger","elizaLogger","ModelClass","generateObject","composeContext","z","z","composeContext","generateObject","ModelClass","getTrackName","formatReferendumStatus","formatTokenAmount","elizaLogger","elizaLogger","elizaLogger"]}