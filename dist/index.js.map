{"version":3,"sources":["../src/actions/createWallet.ts","../src/providers/wallet.ts","../src/utils/wallet.ts","../src/utils/encryption.ts","../src/actions/ejectWallet.ts","../src/actions/signMessage.ts","../src/actions/loadWallet.ts","../src/actions/validateSignature.ts","../src/actions/getBalance.ts","../src/services/api-service.ts","../src/actions/getBlockInfo.ts","../src/actions/getBlockEvents.ts","../src/actions/getReferenda.ts","../src/actions/getReferendumDetails.ts","../src/providers/networkData.ts","../src/actions/transferFunds.ts","../src/actions/crossChainTransfer.ts","../src/utils/chainRegistryUtils.ts","../src/index.ts"],"sourcesContent":["import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport { composePromptFromState, parseJSONObjectFromText } from '@elizaos/core';\nimport { elizaLogger, ModelType } from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\n\nexport interface CreateWalletContent extends Content {\n    encryptionPassword?: string;\n    keypairPassword?: string;\n    hardDerivation?: string;\n    softDerivation?: string;\n}\n\n// Define a schema for input JSON that must include a password.\nexport const passwordSchema = z.object({\n    encryptionPassword: z.string().optional().nullable(),\n    keypairPassword: z.string().optional().nullable(),\n    hardDerivation: z.string().optional().nullable(),\n    softDerivation: z.string().optional().nullable(),\n});\n\n// Define a template to guide object building\nexport const passwordTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"encryptionPassword\": \"<your password here>\",\n    \"keypairPassword\": \"<optional password for keypair>\",\n    \"hardDerivation\": \"<optional hard derivation path>\",\n    \"softDerivation\": \"<optional soft derivation path>\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  If an encryption password is not provided in the latest message, return null for the encryption password.\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\n/**\n * Builds and validates a password object using the provided runtime, message, and state.\n * This function mimics the object building approach used in the mint NFT action.\n */\nexport async function buildCreateWalletDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<{ content: CreateWalletContent; wasPasswordGenerated: boolean }> {\n    const prompt = composePromptFromState({\n        state,\n        template: passwordTemplate,\n    });\n\n    let parsedResponse: CreateWalletContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        // try parsing to a json object\n        const parsedResponse = parseJSONObjectFromText(response) as CreateWalletContent | null;\n        // see if it contains objective and attachmentIds\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    let wasPasswordGenerated = false;\n\n    // If passwordData is undefined or encryptionPassword is not available, generate one.\n    if (!parsedResponse?.encryptionPassword) {\n        const generatedPassword = Math.random().toString(36).slice(-12); // Generate a 12-character random password\n        elizaLogger.log('Encryption password not provided by user, generating one.');\n        // Ensure passwordData is an object before spreading. If it was undefined, initialize it.\n        // If passwordData was undefined, initialize with a default text. Otherwise, use existing passwordData.\n        const baseData = parsedResponse || { text: '' }; // Provide default text if passwordData is null/undefined\n        parsedResponse = { ...baseData, encryptionPassword: generatedPassword };\n        wasPasswordGenerated = true;\n    }\n\n    // At this point, passwordData is guaranteed to be defined and have an encryptionPassword.\n    const createWalletContent: CreateWalletContent = parsedResponse;\n\n    return { content: createWalletContent, wasPasswordGenerated };\n}\n\nexport class CreateWalletAction {\n    private runtime: IAgentRuntime;\n    private walletProvider: WalletProvider;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async initialize(): Promise<void> {\n        this.walletProvider = await initWalletProvider(this.runtime);\n    }\n\n    async createWallet(params: {\n        encryptionPassword: string;\n        keypairPassword?: string;\n        hardDerivation?: string;\n        softDerivation?: string;\n    }): Promise<{\n        walletAddress: string;\n        mnemonic: string;\n        walletNumber: number;\n    }> {\n        const { walletProvider, mnemonic, walletNumber } = await WalletProvider.generateNew(\n            this.walletProvider,\n            params.encryptionPassword,\n            {\n                password: params.keypairPassword,\n                hardDerivation: params.hardDerivation,\n                softDerivation: params.softDerivation,\n            },\n        );\n        const walletAddress = walletProvider.getAddress();\n\n        // Store the new wallet in cache\n        await WalletProvider.storeWalletInCache(walletAddress, walletProvider);\n\n        return { walletAddress, mnemonic, walletNumber };\n    }\n}\n\nexport default {\n    name: 'CREATE_POLKADOT_WALLET',\n    similes: ['NEW_POLKADOT_WALLET', 'MAKE_NEW_POLKADOT_WALLET'],\n    description:\n        'Creates a new Polkadot wallet on demand. Returns the public address and mnemonic backup (store it securely). The wallet keypair is also encrypted to a file using the provided password. Optionally supports keypair password and derivation paths.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting CREATE_POLKADOT_WALLET action...');\n\n        // Build password details using the object building approach\n        const { content: createWalletContent, wasPasswordGenerated: isPasswordGenerated } =\n            await buildCreateWalletDetails(runtime, message, state);\n\n        elizaLogger.debug('createWalletContent', createWalletContent);\n\n        if (!createWalletContent || typeof createWalletContent.encryptionPassword !== 'string') {\n            elizaLogger.error('Failed to obtain encryption password.');\n            if (callback) {\n                callback({\n                    text: 'Unable to process create wallet request. Could not obtain an encryption password.',\n                    content: {\n                        error: 'Invalid create wallet. Password could not be determined or generated.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            // Generate a new wallet using the provided password and options\n            const action = new CreateWalletAction(runtime);\n            await action.initialize();\n\n            const { walletAddress, mnemonic, walletNumber } = await action.createWallet({\n                encryptionPassword: createWalletContent.encryptionPassword,\n                keypairPassword: createWalletContent.keypairPassword,\n                hardDerivation: createWalletContent.hardDerivation,\n                softDerivation: createWalletContent.softDerivation,\n            });\n\n            // Build the user message based on what options were used\n            let userMessageText = `\nNew Polkadot wallet created! ðŸŽ‰\n\nWallet Number: ${walletNumber}\nThis wallet number can be used to load and interact with your wallet in future sessions.`;\n\n            if (isPasswordGenerated) {\n                userMessageText += `\\n\\nGenerated Encryption Password: ${createWalletContent.encryptionPassword}\nâš ï¸ IMPORTANT: Please store this password securely. You'll need it to access your wallet backup.`;\n            }\n\n            userMessageText += `\\n\\nWallet Address: ${walletAddress}`;\n\n            if (createWalletContent.keypairPassword) {\n                userMessageText += `\\nKeypair Password: ${createWalletContent.keypairPassword}`;\n            }\n            if (createWalletContent.hardDerivation) {\n                userMessageText += `\\nHard Derivation: ${createWalletContent.hardDerivation}`;\n            }\n            if (createWalletContent.softDerivation) {\n                userMessageText += `\\nSoft Derivation: ${createWalletContent.softDerivation}`;\n            }\n\n            userMessageText += `\\n\\nâš ï¸ IMPORTANT: Please securely store your mnemonic phrase:\\n${mnemonic}`;\n\n            const result = {\n                status: 'success',\n                walletAddress,\n                walletNumber,\n                mnemonic,\n                keypairPassword: createWalletContent.keypairPassword,\n                hardDerivation: createWalletContent.hardDerivation,\n                softDerivation: createWalletContent.softDerivation,\n                message: 'New Polkadot wallet created. Store the mnemonic securely for recovery.',\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error creating wallet:', error);\n            if (callback) {\n                callback({\n                    text: `Error creating wallet: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Please create a new Polkadot wallet with keypair password 'secret' and hard derivation 'test'\",\n                    action: 'CREATE_POLKADOT_WALLET',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'New Polkadot wallet created!\\nYour password was used to encrypt the wallet keypair, but never stored.\\nWallet Address: EQAXxxxxxxxxxxxxxxxxxxxxxx\\nWallet Number: 1\\nKeypair Password: secret\\nHard Derivation: test\\n\\nPlease securely store your mnemonic:',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please create a new wallet',\n                    action: 'CREATE_POLKADOT_WALLET',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'New Polkadot wallet created!\\nWallet Number: 1\\nWallet Address: EQAXxxxxxxxxxxxxxxxxxxxxxx\\n\\nPlease securely store your mnemonic:',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, Provider, State, ProviderResult } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\n\nimport * as path from 'node:path'; // Changed to use node: protocol\nimport type BigNumber from 'bignumber.js';\n\nimport { Keyring } from '@polkadot/keyring';\nimport { cryptoWaitReady, mnemonicGenerate } from '@polkadot/util-crypto';\nimport type { KeyringOptions } from '@polkadot/keyring/types';\nimport { z } from 'zod'; // Add Zod import\n\nimport fs from 'node:fs';\nimport { fetchPrices, getFormattedPortfolio } from '../utils/wallet';\nimport { encrypt, decrypt } from '../utils/encryption';\n\nexport const PROVIDER_CONFIG = {\n    NATIVE_TOKEN_SYMBOL: 'DOT',\n    COINMARKETCAP_API_URL: 'https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest',\n    MAX_RETRIES: 3,\n    RETRY_DELAY: 2000,\n    NATIVE_TOKEN_DECIMALS: BigInt(10000000000),\n    WALLET_BACKUP_DIRNAME: 'polkadot_wallet_backups',\n    DEFAULT_KEYRING_TYPE: 'ed25519' as const,\n    DEFAULT_KEYRING_SS58_FORMAT: 42, // substrate generic, 2 for kusama, 0 for polkadot\n};\n\ninterface WalletData {\n    source: WalletProviderSource;\n    address: string;\n    createdAt: number;\n    decryptedKeyring?: {\n        type: KeyringOptions['type'];\n        mnemonic: string;\n        options: KeyringOptions;\n    };\n}\n\nexport interface OptimizedWalletCache {\n    wallets: {\n        [address: string]: {\n            number: number;\n            createdAt: number;\n            sourceType: WalletSourceType;\n            encryptedData?: string;\n            mnemonicData?: {\n                mnemonic: string;\n                options: KeyringOptions;\n            };\n        };\n    };\n    numberToAddress: {\n        [number: number]: string;\n    };\n}\n\n// Replace multiple cache keys with a single one\nexport const WALLET_CACHE_KEY = 'polkadot/wallets';\n\n// --- Enum and Interfaces for Constructor --- //\nexport enum WalletSourceType { // Exported for potential external use\n    FROM_MNEMONIC = 'fromMnemonic',\n    FROM_ENCRYPTED_JSON = 'fromEncryptedJson',\n}\n\n// Zod schema for KeyringOptions\nconst keyringOptionsSchema = z.object({\n    type: z.enum(['ed25519', 'sr25519', 'ecdsa']).optional(), // Made optional to handle potential older backups\n    ss58Format: z.number().optional(), // Made optional for flexibility\n    genesisHash: z.union([z.string(), z.instanceof(Uint8Array)]).optional(),\n    // parentAddress: z.string().optional(), // Add if needed, keeping it simple for now\n});\n\n// This interface defines the structure of the data stored in the encrypted backup file.\n// And a corresponding Zod schema for validation.\ninterface DecryptedWalletBackupData {\n    mnemonic: string;\n    options: KeyringOptions; // Contains type, ss58Format for the keyring\n    password?: string; // Optional password for deriving the keypair (part of SURI)\n    hardDerivation?: string; // Optional hard derivation path (part of SURI)\n    softDerivation?: string; // Optional soft derivation path (part of SURI)\n}\n\nconst decryptedWalletBackupDataSchema = z.object({\n    mnemonic: z.string().min(12), // Basic mnemonic validation\n    options: keyringOptionsSchema,\n    password: z.string().optional(),\n    hardDerivation: z.string().optional(),\n    softDerivation: z.string().optional(),\n});\n\ninterface WalletSourceFromMnemonic {\n    type: WalletSourceType.FROM_MNEMONIC;\n    mnemonic: string;\n    keyringOptions?: KeyringOptions;\n    password?: string;\n    hardDerivation?: string;\n    softDerivation?: string;\n}\ninterface WalletSourceFromEncryptedJson {\n    type: WalletSourceType.FROM_ENCRYPTED_JSON;\n    encryptedJson: string;\n    password: string;\n}\n\ntype WalletProviderSource = WalletSourceFromMnemonic | WalletSourceFromEncryptedJson;\n\nexport interface WalletProviderConstructionParams {\n    // Exporting for potential external use\n    source: WalletProviderSource;\n    runtime: IAgentRuntime;\n}\n// --- End Interfaces --- //\n\nexport class WalletProvider {\n    runtime: IAgentRuntime;\n    keyring: Keyring;\n    coinMarketCapApiKey: string;\n    walletNumber: number | null = null;\n    source: WalletProviderSource;\n\n    constructor(params: WalletProviderConstructionParams) {\n        this.runtime = params.runtime;\n        this.coinMarketCapApiKey = this.runtime.getSetting('COINMARKETCAP_API_KEY');\n        if (!this.coinMarketCapApiKey) {\n            elizaLogger.warn('COINMARKETCAP_API_KEY is not set. Price fetching will likely fail.');\n        }\n\n        const { source } = params;\n        this.source = source;\n\n        try {\n            // Reinstating the in-constructor dispatch map\n            const dispatchMap: Record<WalletSourceType, () => void> = {\n                [WalletSourceType.FROM_MNEMONIC]: () =>\n                    this._initializeFromMnemonic(source as WalletSourceFromMnemonic),\n                [WalletSourceType.FROM_ENCRYPTED_JSON]: () =>\n                    this._initializeFromEncryptedJson(source as WalletSourceFromEncryptedJson),\n            };\n\n            // Execute the appropriate initialization function from the map\n            dispatchMap[source.type]();\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`WalletProvider constructor failed: ${message}`);\n            throw new Error(`Failed to initialize WalletProvider: ${message}`);\n        }\n\n        if (!this.keyring || this.keyring.getPairs().length === 0) {\n            throw new Error(\n                `Keypair not loaded into keyring after initialization from source: ${source.type}`,\n            );\n        }\n    }\n\n    static async storeWalletInCache(\n        address: string,\n        wallet: WalletProvider,\n        walletNumber?: number,\n    ): Promise<void> {\n        elizaLogger.debug('Starting storeWalletInCache for address:', address);\n\n        let cache: OptimizedWalletCache;\n        try {\n            const cachedData =\n                await wallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n            if (cachedData) {\n                elizaLogger.debug('Retrieved existing cache');\n                cache = cachedData;\n            } else {\n                elizaLogger.debug('No existing cache found, creating new one');\n                cache = {\n                    wallets: {},\n                    numberToAddress: {},\n                };\n            }\n        } catch (error) {\n            elizaLogger.error('Error retrieving cache, creating new one:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            cache = {\n                wallets: {},\n                numberToAddress: {},\n            };\n        }\n\n        const finalWalletNumber =\n            walletNumber ?? (await WalletProvider.getWalletNumberFromCache(address, cache));\n        elizaLogger.debug('Assigned wallet number:', finalWalletNumber);\n\n        // Only store serializable data\n        const walletData = {\n            number: finalWalletNumber,\n            createdAt: Date.now(),\n            sourceType: wallet.source.type,\n            ...(wallet.source.type === WalletSourceType.FROM_MNEMONIC && {\n                mnemonicData: {\n                    mnemonic: wallet.source.mnemonic,\n                    options: wallet.source.keyringOptions || {\n                        type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n                        ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n                    },\n                },\n            }),\n            ...(wallet.source.type === WalletSourceType.FROM_ENCRYPTED_JSON && {\n                encryptedData: wallet.source.encryptedJson,\n            }),\n        };\n\n        cache.wallets[address] = walletData;\n        cache.numberToAddress[finalWalletNumber] = address;\n\n        try {\n            await wallet.runtime.setCache(WALLET_CACHE_KEY, cache);\n            elizaLogger.debug('Successfully stored wallet in cache');\n        } catch (error) {\n            elizaLogger.error('Failed to store wallet in cache:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw new Error(\n                `Failed to store wallet in cache: ${\n                    error instanceof Error ? error.message : String(error)\n                }`,\n            );\n        }\n    }\n\n    private static async getWalletNumberFromCache(\n        address: string,\n        cache: OptimizedWalletCache,\n    ): Promise<number | null> {\n        return cache.wallets[address]?.number || null;\n    }\n\n    private static getNextWalletNumberFromFilesystem(): number {\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        if (!fs.existsSync(backupDir)) {\n            return 1;\n        }\n\n        try {\n            const files = fs.readdirSync(backupDir);\n            if (files.length === 0) {\n                return 1;\n            }\n            return files.length; // Fixed: return the actual number of files\n        } catch (_error) {\n            elizaLogger.warn(\n                'Error reading backup directory for wallet numbering, defaulting to 1:',\n                _error,\n            );\n            return 1;\n        }\n    }\n\n    static async clearWalletFromCache(wallet: WalletProvider, address: string): Promise<void> {\n        const cache = await wallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (!cache) return;\n\n        const walletNumber = cache.wallets[address]?.number;\n        if (walletNumber) {\n            delete cache.numberToAddress[walletNumber];\n        }\n        delete cache.wallets[address];\n\n        await wallet.runtime.setCache(WALLET_CACHE_KEY, cache);\n    }\n\n    static async clearAllWalletsFromCache(wallet: WalletProvider): Promise<void> {\n        await wallet.runtime.setCache(WALLET_CACHE_KEY, {\n            wallets: {},\n            numberToAddress: {},\n        });\n    }\n\n    static async loadWalletByAddress(\n        wallet: WalletProvider,\n        address: string,\n        password?: string,\n    ): Promise<WalletProvider> {\n        // First check cache\n        const cache = await wallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (cache?.wallets[address]) {\n            const walletData = cache.wallets[address];\n            if (walletData.mnemonicData) {\n                return new WalletProvider({\n                    runtime: wallet.runtime,\n                    source: {\n                        type: WalletSourceType.FROM_MNEMONIC,\n                        mnemonic: walletData.mnemonicData.mnemonic,\n                        keyringOptions: walletData.mnemonicData.options,\n                    },\n                });\n            }\n            if (walletData.encryptedData && password) {\n                return new WalletProvider({\n                    runtime: wallet.runtime,\n                    source: {\n                        type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                        encryptedJson: walletData.encryptedData,\n                        password,\n                    },\n                });\n            }\n            if (walletData.encryptedData && !password) {\n                throw new Error(\n                    `Wallet found in cache but no password provided for address ${address}`,\n                );\n            }\n        }\n\n        // If not in cache, check file system\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        const fileName = `${address}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error(`No stored data found for wallet address ${address}`);\n        }\n\n        if (!password) {\n            throw new Error(\n                `Wallet found in file system but no password provided for address ${address}`,\n            );\n        }\n\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n\n        const walletProvider = new WalletProvider({\n            runtime: wallet.runtime,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedFileContent,\n                password,\n            },\n        });\n\n        // Store in cache for future use\n        await WalletProvider.storeWalletInCache(address, walletProvider);\n        return walletProvider;\n    }\n\n    static async loadWalletByNumber(\n        wallet: WalletProvider,\n        number: number,\n        password?: string,\n    ): Promise<WalletProvider> {\n        // First check cache\n        const cache = await wallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (cache?.numberToAddress[number]) {\n            const address = cache.numberToAddress[number];\n            const walletData = cache.wallets[address];\n\n            if (walletData.mnemonicData) {\n                return new WalletProvider({\n                    runtime: wallet.runtime,\n                    source: {\n                        type: WalletSourceType.FROM_MNEMONIC,\n                        mnemonic: walletData.mnemonicData.mnemonic,\n                        keyringOptions: walletData.mnemonicData.options,\n                    },\n                });\n            }\n            if (walletData.encryptedData && password) {\n                return new WalletProvider({\n                    runtime: wallet.runtime,\n                    source: {\n                        type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                        encryptedJson: walletData.encryptedData,\n                        password,\n                    },\n                });\n            }\n            if (walletData.encryptedData && !password) {\n                throw new Error(`Wallet #${number} found in cache but no password provided`);\n            }\n        }\n\n        // If not in cache, check file system\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        if (!fs.existsSync(backupDir)) {\n            throw new Error(`No wallet found with number ${number}`);\n        }\n\n        const files = fs.readdirSync(backupDir);\n        if (number <= 0 || number > files.length) {\n            throw new Error(`No wallet found with number ${number}`);\n        }\n\n        if (!password) {\n            throw new Error(`Wallet #${number} found in file system but no password provided`);\n        }\n\n        const targetFile = files[number - 1];\n        const filePath = path.join(backupDir, targetFile);\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n\n        const walletProvider = new WalletProvider({\n            runtime: wallet.runtime,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedFileContent,\n                password,\n            },\n        });\n\n        // Store in cache for future use\n        await WalletProvider.storeWalletInCache(walletProvider.getAddress(), walletProvider);\n        return walletProvider;\n    }\n\n    // Private helper to initialize keyring from detailed components\n    private _initKeyringFromDetails(\n        mnemonic: string,\n        keyringOptions: KeyringOptions,\n        keypairPassword?: string, // Password for the keypair itself (goes into SURI)\n        hardDerivation?: string,\n        softDerivation?: string,\n        pairName = 'derived pair', // Added pairName as parameter\n    ): void {\n        this.keyring = new Keyring(keyringOptions);\n        let suri = mnemonic;\n        if (keypairPassword) {\n            suri = `${suri}///${keypairPassword}`;\n        }\n        if (hardDerivation) {\n            suri = `${suri}//${hardDerivation}`;\n        }\n        if (softDerivation) {\n            suri = `${suri}/${softDerivation}`;\n        }\n        elizaLogger.debug(\n            'Generated SURI for keyring init:',\n            suri,\n            'with options:',\n            keyringOptions,\n        );\n        this.keyring.addFromUri(suri, { name: pairName }, keyringOptions.type);\n    }\n\n    // Private handler methods for initialization logic\n    private _initializeFromMnemonic(source: WalletSourceFromMnemonic): void {\n        try {\n            elizaLogger.debug('Initializing wallet from mnemonic');\n            const opts = source.keyringOptions || {\n                type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n                ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n            };\n            elizaLogger.debug('Using keyring options:', opts);\n\n            this._initKeyringFromDetails(\n                source.mnemonic,\n                opts,\n                source.password, // This is the keypair password from the source\n                source.hardDerivation,\n                source.softDerivation,\n                'main pair', // Specific name for this initialization path\n            );\n            elizaLogger.debug('Wallet initialized successfully from mnemonic');\n        } catch (error) {\n            elizaLogger.error('Error initializing from mnemonic:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw new Error(`Failed to initialize wallet from mnemonic: ${error.message}`);\n        }\n    }\n\n    private _initializeFromEncryptedJson(source: WalletSourceFromEncryptedJson): void {\n        try {\n            elizaLogger.debug('Initializing wallet from encrypted JSON');\n            elizaLogger.debug('Encrypted data length:', source.encryptedJson.length);\n\n            const decryptedJson = decrypt(source.encryptedJson, source.password); // source.password is for decryption\n            elizaLogger.debug('Decrypted JSON length:', decryptedJson.length);\n            // elizaLogger.debug('Decrypted JSON content:', decryptedJson); // Avoid logging potentially sensitive mnemonics\n\n            let walletData: DecryptedWalletBackupData;\n            try {\n                elizaLogger.debug(\n                    'Attempting to parse and validate decrypted JSON for wallet data',\n                );\n                const parsedJson: unknown = JSON.parse(decryptedJson);\n                walletData = decryptedWalletBackupDataSchema.parse(\n                    parsedJson,\n                ) as DecryptedWalletBackupData;\n                elizaLogger.debug('Successfully parsed and validated wallet data structure');\n            } catch (parseError) {\n                elizaLogger.error('JSON Parse or Validation Error:', {\n                    error:\n                        parseError instanceof Error\n                            ? {\n                                  message: parseError.message,\n                                  stack: parseError.stack,\n                                  name: parseError.name,\n                              }\n                            : parseError,\n                    // json: decryptedJson, // Avoid logging potentially sensitive mnemonics\n                });\n                throw new Error(`Failed to parse decrypted wallet data: ${parseError.message}`);\n            }\n\n            if (!walletData.mnemonic || !walletData.options) {\n                elizaLogger.error(\n                    'Missing required fields (mnemonic or options) in parsed wallet data.',\n                );\n                throw new Error('Decrypted data missing required fields (mnemonic or options)');\n            }\n\n            // Ensure options has a type, default if not present (though it should be by generator)\n            const keyringInitOptions = walletData.options;\n            if (!keyringInitOptions.type) {\n                elizaLogger.warn(\n                    'Keyring type missing in decrypted options, defaulting to ed25519 as per PROVIDER_CONFIG',\n                );\n                keyringInitOptions.type = PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE;\n            }\n            if (\n                keyringInitOptions.ss58Format === undefined ||\n                keyringInitOptions.ss58Format === null\n            ) {\n                elizaLogger.warn(\n                    'ss58Format missing in decrypted options, defaulting as per PROVIDER_CONFIG',\n                );\n                keyringInitOptions.ss58Format = PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT;\n            }\n\n            this._initKeyringFromDetails(\n                walletData.mnemonic,\n                keyringInitOptions, // These are the KeyringOptions from the backup (type, ss58Format)\n                walletData.password, // This is the keypair password from the backup for the SURI\n                walletData.hardDerivation,\n                walletData.softDerivation,\n                'imported main pair', // Specific name for this initialization path\n            );\n            elizaLogger.debug('Wallet initialized successfully from encrypted JSON');\n        } catch (error) {\n            elizaLogger.error('Error initializing from encrypted JSON:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw new Error(`Failed to initialize wallet from encrypted data: ${error.message}`);\n        }\n    }\n\n    async fetchPrices(): Promise<{ nativeToken: { usd: BigNumber } }> {\n        return fetchPrices(this.runtime, this.coinMarketCapApiKey);\n    }\n\n    getAddress(): string {\n        const pairs = this.keyring.getPairs();\n        if (pairs.length === 0) {\n            throw new Error('No keypairs available in the keyring to get an address.');\n        }\n        return pairs[0].address;\n    }\n\n    async getWalletNumber(): Promise<number | null> {\n        if (this.walletNumber !== null) {\n            return this.walletNumber;\n        }\n\n        const address = this.getAddress();\n\n        const cache = await this.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        const number = cache?.wallets[address]?.number;\n        this.walletNumber = number !== undefined ? Number(number) : null;\n        return this.walletNumber;\n    }\n\n    static async getWalletData(wallet: WalletProvider, number: number): Promise<WalletData | null> {\n        const cache = await wallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (!cache?.numberToAddress[number]) return null;\n\n        const address = cache.numberToAddress[number];\n        const walletData = cache.wallets[address];\n        if (!walletData) return null;\n\n        return {\n            source: {\n                type: walletData.sourceType,\n                ...(walletData.mnemonicData && {\n                    mnemonic: walletData.mnemonicData.mnemonic,\n                    keyringOptions: walletData.mnemonicData.options,\n                }),\n                ...(walletData.encryptedData && {\n                    encryptedJson: walletData.encryptedData,\n                }),\n            } as WalletProviderSource,\n            address,\n            createdAt: walletData.createdAt,\n        };\n    }\n\n    static async getWalletByAddress(\n        wallet: WalletProvider,\n        address: string,\n    ): Promise<WalletData | null> {\n        const cache = await wallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n        if (!cache?.wallets[address]) return null;\n\n        const walletData = cache.wallets[address];\n        return {\n            source: {\n                type: walletData.sourceType,\n                ...(walletData.mnemonicData && {\n                    mnemonic: walletData.mnemonicData.mnemonic,\n                    keyringOptions: walletData.mnemonicData.options,\n                }),\n                ...(walletData.encryptedData && {\n                    encryptedJson: walletData.encryptedData,\n                }),\n            } as WalletProviderSource,\n            address,\n            createdAt: walletData.createdAt,\n        };\n    }\n\n    static async generateNew(\n        wallet: WalletProvider,\n        password: string,\n        options?: {\n            password?: string;\n            hardDerivation?: string;\n            softDerivation?: string;\n            keyringOptions?: KeyringOptions;\n        },\n    ): Promise<{\n        walletProvider: WalletProvider;\n        mnemonic: string;\n        encryptedBackup: string;\n        walletNumber: number;\n    }> {\n        const mnemonic = mnemonicGenerate(24);\n\n        const keyringOptions: KeyringOptions = options?.keyringOptions || {\n            type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n            ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n        };\n\n        // Create a clean object with only the necessary properties\n        const dataToEncrypt: DecryptedWalletBackupData = {\n            mnemonic,\n            options: keyringOptions, // This is KeyringOptions (type, ss58Format)\n            password: options?.password, // This is the keypair password for SURI\n            hardDerivation: options?.hardDerivation,\n            softDerivation: options?.softDerivation,\n        };\n\n        // Ensure proper JSON stringification\n        const jsonString = JSON.stringify(dataToEncrypt);\n\n        try {\n            const encryptedMnemonicAndOptions = encrypt(jsonString, password);\n\n            const newWalletProvider = new WalletProvider({\n                runtime: wallet.runtime,\n                source: {\n                    type: WalletSourceType.FROM_MNEMONIC,\n                    mnemonic,\n                    keyringOptions,\n                    password: options?.password,\n                    hardDerivation: options?.hardDerivation,\n                    softDerivation: options?.softDerivation,\n                },\n            });\n\n            const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n            if (!fs.existsSync(backupDir)) {\n                fs.mkdirSync(backupDir, { recursive: true });\n            }\n            const address = newWalletProvider.getAddress();\n\n            const fileName = `${address}_wallet_backup.json`;\n            const filePath = path.join(backupDir, fileName);\n\n            if (!fs.existsSync(path.dirname(filePath))) {\n                fs.mkdirSync(path.dirname(filePath), { recursive: true });\n            }\n\n            fs.writeFileSync(filePath, encryptedMnemonicAndOptions, {\n                encoding: 'utf-8',\n            });\n            elizaLogger.log(`Wallet backup saved to ${filePath}`);\n\n            // Get the next wallet number from filesystem\n            const walletNumber = WalletProvider.getNextWalletNumberFromFilesystem();\n\n            // Store wallet data in cache using the existing method with the wallet number\n            await WalletProvider.storeWalletInCache(address, newWalletProvider, walletNumber);\n            newWalletProvider.walletNumber = walletNumber;\n\n            return {\n                walletProvider: newWalletProvider,\n                mnemonic,\n                encryptedBackup: encryptedMnemonicAndOptions,\n                walletNumber,\n            };\n        } catch (error) {\n            elizaLogger.error('Error in wallet generation:', {\n                error:\n                    error instanceof Error\n                        ? {\n                              message: error.message,\n                              stack: error.stack,\n                              name: error.name,\n                          }\n                        : error,\n            });\n            throw error;\n        }\n    }\n\n    static async importWalletFromFile(\n        runtime: IAgentRuntime,\n        walletAddressForBackupName: string,\n        password: string,\n    ): Promise<WalletProvider> {\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        const fileName = `${walletAddressForBackupName}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error(`Wallet backup file does not exist at: ${filePath}`);\n        }\n\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n\n        const constructionParams: WalletProviderConstructionParams = {\n            runtime: runtime,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedFileContent,\n                password,\n            },\n        };\n        return new WalletProvider(constructionParams);\n    }\n\n    static async ejectWalletFromFile(\n        wallet: WalletProvider, // wallet instance needed for cache clearing\n        walletAddressForBackupName: string,\n        password: string, // Password for decrypting the file\n    ): Promise<DecryptedWalletBackupData> {\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        const fileName = `${walletAddressForBackupName}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error(`Wallet backup file does not exist at: ${filePath}`);\n        }\n\n        const encryptedFileContent = fs.readFileSync(filePath, {\n            encoding: 'utf-8',\n        });\n        elizaLogger.debug('Read encrypted file content, length:', encryptedFileContent.length);\n\n        const decryptedFileJson = decrypt(encryptedFileContent, password);\n        elizaLogger.debug('Decrypted file content length:', decryptedFileJson.length); // Avoid logging content\n\n        try {\n            const parsedJson: unknown = JSON.parse(decryptedFileJson);\n            const walletData = decryptedWalletBackupDataSchema.parse(\n                parsedJson,\n            ) as DecryptedWalletBackupData;\n            elizaLogger.debug('Successfully parsed and validated wallet data from ejected file'); // Avoid logging directly\n            elizaLogger.log(\n                `Wallet ejected from file ${filePath}, revealing mnemonic and options.`,\n            );\n\n            // Get the cache from the current instance\n            await WalletProvider.clearWalletFromCache(wallet, walletAddressForBackupName);\n\n            return walletData;\n        } catch (parseError) {\n            elizaLogger.error('JSON Parse or Validation Error in ejectWalletFromFile:', {\n                error:\n                    parseError instanceof Error\n                        ? {\n                              message: parseError.message,\n                              stack: parseError.stack,\n                              name: parseError.name,\n                          }\n                        : parseError,\n                json: decryptedFileJson,\n            });\n            throw new Error(`Failed to parse decrypted wallet data: ${parseError.message}`);\n        }\n    }\n\n    static async importWallet(\n        encryptedMnemonicAndOptions: string,\n        password: string,\n        runtime: IAgentRuntime,\n    ): Promise<WalletProvider> {\n        const constructionParams: WalletProviderConstructionParams = {\n            runtime: runtime,\n            source: {\n                type: WalletSourceType.FROM_ENCRYPTED_JSON,\n                encryptedJson: encryptedMnemonicAndOptions,\n                password,\n            },\n        };\n        const walletProvider = new WalletProvider(constructionParams);\n\n        elizaLogger.log(\n            `Wallet imported successfully via encrypted JSON, address: ${walletProvider.getAddress()}`,\n        );\n        return walletProvider;\n    }\n\n    // New method to import mnemonic, encrypt, store, and cache\n    static async importMnemonicAndStore(\n        runtime: IAgentRuntime,\n        mnemonic: string,\n        encryptionPassword: string,\n        options?: {\n            keypairPassword?: string;\n            hardDerivation?: string;\n            softDerivation?: string;\n            keyringOptions?: KeyringOptions;\n        },\n    ): Promise<{\n        walletProvider: WalletProvider;\n        address: string;\n        encryptedBackup: string;\n        walletNumber: number;\n    }> {\n        await cryptoWaitReady();\n\n        const keyringOpts: KeyringOptions = options?.keyringOptions || {\n            type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n            ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n        };\n\n        // Data to be encrypted and stored\n        const dataToEncrypt: DecryptedWalletBackupData = {\n            mnemonic,\n            options: keyringOpts, // This is KeyringOptions (type, ss58Format)\n            password: options?.keypairPassword, // This is the keypair password for SURI\n            hardDerivation: options?.hardDerivation,\n            softDerivation: options?.softDerivation,\n        };\n\n        const jsonStringToEncrypt = JSON.stringify(dataToEncrypt);\n        const encryptedBackup = encrypt(jsonStringToEncrypt, encryptionPassword);\n\n        // Create a new WalletProvider instance from the imported mnemonic\n        const newWalletProvider = new WalletProvider({\n            runtime: runtime,\n            source: {\n                type: WalletSourceType.FROM_MNEMONIC,\n                mnemonic: mnemonic,\n                keyringOptions: keyringOpts,\n                password: options?.keypairPassword, // Pass through optional keypair password\n                hardDerivation: options?.hardDerivation, // Pass through optional hard derivation\n                softDerivation: options?.softDerivation, // Pass through optional soft derivation\n            },\n        });\n\n        const address = newWalletProvider.getAddress();\n\n        // Save encrypted backup to file\n        const backupDir = path.join(process.cwd(), PROVIDER_CONFIG.WALLET_BACKUP_DIRNAME);\n        if (!fs.existsSync(backupDir)) {\n            fs.mkdirSync(backupDir, { recursive: true });\n        }\n        const fileName = `${address}_wallet_backup.json`;\n        const filePath = path.join(backupDir, fileName);\n        fs.writeFileSync(filePath, encryptedBackup, { encoding: 'utf-8' });\n        elizaLogger.log(`Wallet backup for imported mnemonic saved to ${filePath}`);\n\n        // Assign a wallet number and cache the wallet\n        const walletNumber = WalletProvider.getNextWalletNumberFromFilesystem();\n        await WalletProvider.storeWalletInCache(address, newWalletProvider, walletNumber);\n        newWalletProvider.walletNumber = walletNumber; // Set on the instance as well\n\n        return {\n            walletProvider: newWalletProvider,\n            address,\n            encryptedBackup,\n            walletNumber,\n        };\n    }\n}\n\nexport const initWalletProvider = async (runtime: IAgentRuntime) => {\n    let mnemonic = runtime.getSetting('POLKADOT_PRIVATE_KEY');\n    if (!mnemonic) {\n        elizaLogger.error('POLKADOT_PRIVATE_KEY is missing; using random mnemonic');\n        mnemonic = mnemonicGenerate(24);\n    }\n\n    const mnemonicsArray = mnemonic.split(' ');\n    if (mnemonicsArray.length < 12 || mnemonicsArray.length > 24) {\n        throw new Error(\n            `POLKADOT_PRIVATE_KEY mnemonic seems invalid (length: ${mnemonicsArray.length})`,\n        );\n    }\n\n    const keyringOptions: KeyringOptions = {\n        type: PROVIDER_CONFIG.DEFAULT_KEYRING_TYPE,\n        ss58Format: PROVIDER_CONFIG.DEFAULT_KEYRING_SS58_FORMAT,\n    };\n\n    await cryptoWaitReady();\n\n    const walletProvider = new WalletProvider({\n        runtime: runtime,\n        source: {\n            type: WalletSourceType.FROM_MNEMONIC,\n            mnemonic,\n            keyringOptions,\n        },\n    });\n\n    elizaLogger.log(`Wallet initialized from settings, address: ${walletProvider.getAddress()}`);\n    return walletProvider;\n};\n\nexport const nativeWalletProvider: Provider = {\n    name: 'polkadot_wallet',\n    async get(runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<ProviderResult> {\n        const walletProvider = await initWalletProvider(runtime);\n        if (runtime.getSetting('COINMARKETCAP_API_KEY')) {\n            try {\n                const formattedPortfolio = await getFormattedPortfolio(\n                    runtime,\n                    walletProvider.coinMarketCapApiKey,\n                    walletProvider.getAddress(),\n                );\n                elizaLogger.log(formattedPortfolio);\n                return { text: formattedPortfolio };\n            } catch (error) {\n                const message = error instanceof Error ? error.message : String(error);\n                elizaLogger.error(\n                    `Error in ${PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL.toUpperCase()} wallet provider:`,\n                    message,\n                );\n                return { text: null };\n            }\n        }\n\n        return { text: null };\n    },\n};\n","import type { IAgentRuntime } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\nimport BigNumber from 'bignumber.js';\nimport { PROVIDER_CONFIG } from '../providers/wallet';\n\nexport class MemoryCacheAdapter {\n    data: Map<string, string>;\n\n    constructor(initalData?: Map<string, string>) {\n        this.data = initalData ?? new Map<string, string>();\n    }\n\n    async get(key: string): Promise<string | undefined> {\n        return this.data.get(key);\n    }\n\n    async set(key: string, value: string): Promise<void> {\n        this.data.set(key, value);\n    }\n\n    async delete(key: string): Promise<void> {\n        this.data.delete(key);\n    }\n}\n\nexport interface WalletPortfolio {\n    totalUsd: string;\n    totalNativeToken: string;\n}\n\nexport async function fetchPrices(\n    runtime: IAgentRuntime,\n    coinMarketCapApiKey: string,\n): Promise<{ nativeToken: { usd: BigNumber } }> {\n    try {\n        const cacheKey = 'prices';\n        const cachedValue = await runtime.getCache<{ nativeToken: { usd: BigNumber } }>(cacheKey);\n\n        if (cachedValue) {\n            elizaLogger.log('Cache hit for fetchPrices');\n            return cachedValue;\n        }\n        elizaLogger.log('Cache miss for fetchPrices');\n\n        let lastError: Error | undefined;\n        for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\n            try {\n                const response = await fetch(\n                    `${PROVIDER_CONFIG.COINMARKETCAP_API_URL}?symbol=${PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL}&convert=USD`,\n                    {\n                        headers: {\n                            'X-CMC_PRO_API_KEY': coinMarketCapApiKey,\n                            Accept: 'application/json',\n                        },\n                    },\n                );\n\n                if (!response.ok) {\n                    const errorText = await response.text();\n                    throw new Error(\n                        `HTTP error! status: ${response.status}, message: ${errorText}`,\n                    );\n                }\n\n                const data = await response.json();\n                const price = data?.data?.[PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL]?.quote?.USD;\n                if (price) {\n                    const prices = {\n                        nativeToken: { usd: new BigNumber(price.price) },\n                    };\n                    runtime.setCache(cacheKey, prices);\n                    return prices;\n                }\n                throw new Error('Price data not found in CoinMarketCap response structure.');\n            } catch (error) {\n                const message = error instanceof Error ? error.message : String(error);\n                elizaLogger.error(`Attempt ${i + 1} failed:`, message);\n                lastError = error instanceof Error ? error : new Error(message);\n                if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\n                    const delay = PROVIDER_CONFIG.RETRY_DELAY * 2 ** i;\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                }\n            }\n        }\n\n        elizaLogger.error('All attempts failed. Throwing the last error:', lastError);\n        throw (\n            lastError ?? new Error('All attempts to fetch prices failed without a specific error.')\n        );\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        elizaLogger.error('Error fetching prices:', message);\n        throw new Error(`Failed to fetch prices: ${message}`);\n    }\n}\n\nexport function formatPortfolio(\n    runtime: IAgentRuntime,\n    portfolio: WalletPortfolio,\n    walletAddress: string,\n): string {\n    let output = `${runtime.character.name}\\n`;\n    output += `Wallet Address: ${walletAddress}\\n`;\n\n    const totalUsdFormatted = new BigNumber(portfolio.totalUsd).toFixed(2);\n    const totalNativeTokenFormatted = new BigNumber(portfolio.totalNativeToken).toFixed(4);\n\n    output += `Total Value: $${totalUsdFormatted} (${totalNativeTokenFormatted} ${PROVIDER_CONFIG.NATIVE_TOKEN_SYMBOL.toUpperCase()})\\n`;\n\n    return output;\n}\n\nexport async function fetchPortfolioValue(\n    runtime: IAgentRuntime,\n    coinMarketCapApiKey: string,\n    walletAddress: string,\n): Promise<WalletPortfolio> {\n    try {\n        const cacheKey = `portfolio-${walletAddress}`;\n        const cachedValue = await runtime.getCache<WalletPortfolio>(cacheKey);\n\n        if (cachedValue) {\n            elizaLogger.log('Cache hit for fetchPortfolioValue', cachedValue);\n            return cachedValue;\n        }\n        elizaLogger.log('Cache miss for fetchPortfolioValue');\n\n        const prices = await fetchPrices(runtime, coinMarketCapApiKey);\n        const nativeTokenBalance = BigInt(0);\n        const amount = Number(nativeTokenBalance) / Number(PROVIDER_CONFIG.NATIVE_TOKEN_DECIMALS);\n        const totalUsd = new BigNumber(amount.toString()).times(prices.nativeToken.usd);\n\n        const portfolio = {\n            totalUsd: totalUsd.toString(),\n            totalNativeToken: amount.toFixed(4).toString(),\n        };\n\n        runtime.setCache(cacheKey, portfolio);\n        return portfolio;\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        elizaLogger.error('Error fetching portfolio:', message);\n        throw new Error(`Failed to fetch portfolio value: ${message}`);\n    }\n}\n\nexport async function getFormattedPortfolio(\n    runtime: IAgentRuntime,\n    coinMarketCapApiKey: string,\n    walletAddress: string,\n): Promise<string> {\n    try {\n        const portfolio = await fetchPortfolioValue(runtime, coinMarketCapApiKey, walletAddress);\n        return formatPortfolio(runtime, portfolio, walletAddress);\n    } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        elizaLogger.error('Error generating portfolio report:', message);\n        return 'Unable to fetch wallet information. Please try again later.';\n    }\n}\n","import { naclDecrypt, naclEncrypt, randomAsU8a, pbkdf2Encode } from '@polkadot/util-crypto';\nimport { stringToU8a, u8aToString, u8aToHex, hexToU8a } from '@polkadot/util';\nimport { elizaLogger } from '@elizaos/core';\n\n/**\n * Encrypts text using NaCl encryption with PBKDF2 key derivation\n * @param text - The text to encrypt\n * @param password - The password to use for encryption\n * @returns A string containing the encrypted data in format \"kdfSaltHex:nonceHex:encryptedHex\"\n */\nexport function encrypt(text: string, password: string): string {\n    try {\n        if (!text || typeof text !== 'string') {\n            throw new Error('Invalid input text for encryption');\n        }\n        if (!password || typeof password !== 'string') {\n            throw new Error('Invalid password for encryption');\n        }\n\n        const messageU8a = stringToU8a(text);\n        const kdfSalt = randomAsU8a(16); // Salt for PBKDF2\n\n        // Derive a 32-byte key from the password and kdfSalt\n        const { password: secretKey } = pbkdf2Encode(stringToU8a(password), kdfSalt);\n\n        const { encrypted, nonce } = naclEncrypt(messageU8a, secretKey.subarray(0, 32)); // Ensure 32-byte key for nacl\n\n        // Convert kdfSalt, nonce, and encrypted data to hex strings for storage\n        const kdfSaltHex = u8aToHex(kdfSalt);\n        const nonceHex = u8aToHex(nonce);\n        const encryptedHex = u8aToHex(encrypted);\n\n        return `${kdfSaltHex}:${nonceHex}:${encryptedHex}`;\n    } catch (error) {\n        elizaLogger.error('Encryption error:', error);\n        throw new Error(`Failed to encrypt data: ${error.message}`);\n    }\n}\n\n/**\n * Decrypts text that was encrypted using the encrypt function\n * @param encryptedString - The encrypted string in format \"kdfSaltHex:nonceHex:encryptedHex\"\n * @param password - The password used for encryption\n * @returns The decrypted text\n * @throws Error if decryption fails or if the encrypted string format is invalid\n */\nexport function decrypt(encryptedString: string, password: string): string {\n    try {\n        if (!encryptedString || typeof encryptedString !== 'string') {\n            throw new Error('Invalid encrypted string input');\n        }\n        if (!password || typeof password !== 'string') {\n            throw new Error('Invalid password for decryption');\n        }\n\n        const parts = encryptedString.split(':');\n        if (parts.length !== 3) {\n            throw new Error(\n                'Invalid encrypted data format (expected kdfSaltHex:nonceHex:encryptedHex)',\n            );\n        }\n        const [kdfSaltHex, nonceHex, encryptedHex] = parts;\n\n        const kdfSalt = hexToU8a(kdfSaltHex);\n        const nonce = hexToU8a(nonceHex);\n        const encryptedU8a = hexToU8a(encryptedHex);\n\n        // Derive the same 32-byte key from the password and kdfSalt\n        const { password: secretKey } = pbkdf2Encode(stringToU8a(password), kdfSalt);\n\n        const decryptedU8a = naclDecrypt(encryptedU8a, nonce, secretKey.subarray(0, 32)); // Ensure 32-byte key for nacl\n\n        if (!decryptedU8a) {\n            throw new Error('Decryption failed. Invalid password or corrupted data.');\n        }\n\n        const decryptedText = u8aToString(decryptedU8a);\n\n        return decryptedText;\n    } catch (error) {\n        elizaLogger.error('Decryption error:', error.message);\n        throw new Error(`Failed to decrypt data: ${error.message}`);\n    }\n}\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\n\nexport interface EjectWalletContent extends Content {\n    password?: string;\n    walletAddress?: string;\n    walletNumber?: number;\n}\n\nfunction isEjectWalletContent(content: Content): content is EjectWalletContent {\n    return (\n        (typeof content.password === 'string' ||\n            content.password === undefined ||\n            content.password === null) &&\n        (typeof content.walletAddress === 'string' ||\n            content.walletAddress === undefined ||\n            content.walletAddress === null) &&\n        (typeof content.walletNumber === 'number' ||\n            content.walletNumber === undefined ||\n            content.walletNumber === null)\n    );\n}\n\n// Define a schema for input JSON\nconst ejectWalletSchema = z.object({\n    password: z.string().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    walletNumber: z.number().optional().nullable(),\n});\n\n// Define a template to guide object building\nconst ejectWalletTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"password\": \"my_password\",\n  \"walletAddress\": \"EQAXxxxxxxxxxxxxxxxxxxxxxx\",\n  \"walletNumber\": 1\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\n/**\n * Builds and validates eject wallet details using the provided runtime, message, and state.\n */\nexport async function buildEjectWalletDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<EjectWalletContent> {\n    const prompt = composePromptFromState({\n        state,\n        template: ejectWalletTemplate,\n    });\n\n    const parsedResponse: EjectWalletContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as EjectWalletContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = ejectWalletSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid Polkadot address from the message');\n    }\n\n    return validatedResponse.data as EjectWalletContent;\n}\n\nexport default {\n    name: 'EJECT_POLKADOT_WALLET',\n    similes: ['EXPORT_POLKADOT_WALLET', 'RECOVER_WALLET', 'EJECT_WALLET'],\n    description:\n        \"Ejects an existing Polkadot wallet either by wallet number or from an encrypted backup file. Returns the wallet's mnemonic.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting EJECT_POLKADOT_WALLET action...');\n\n        const ejectWalletContent = await buildEjectWalletDetails(runtime, message, state);\n\n        if (!isEjectWalletContent(ejectWalletContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process eject wallet request. Please provide either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid eject wallet request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('ejectWalletContent', ejectWalletContent);\n            const { password, walletAddress, walletNumber } = ejectWalletContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n\n            let mnemonic: string;\n            let address: string;\n\n            // Try to load by wallet number first\n            if (walletNumber) {\n                const targetWallet = await WalletProvider.loadWalletByNumber(\n                    walletProvider,\n                    walletNumber,\n                    password,\n                );\n                if (!targetWallet) {\n                    throw new Error(\n                        `Failed to load wallet #${walletNumber}. Please check the wallet number and password.`,\n                    );\n                }\n                address = targetWallet.getAddress();\n\n                // Try to get mnemonic from decrypted data first\n                const walletData = await WalletProvider.getWalletData(targetWallet, walletNumber);\n                if (walletData?.decryptedKeyring?.mnemonic) {\n                    mnemonic = walletData.decryptedKeyring.mnemonic;\n                } else if (password) {\n                    // Fall back to file system if no decrypted data in cache\n                    elizaLogger.log(\n                        `No decrypted data in cache for wallet #${walletNumber}, falling back to file system`,\n                    );\n                    const result = await WalletProvider.ejectWalletFromFile(\n                        walletProvider,\n                        address,\n                        password,\n                    );\n                    mnemonic = result.mnemonic;\n                } else {\n                    throw new Error(\n                        `No decrypted data found for wallet #${walletNumber} and no password provided for file system fallback`,\n                    );\n                }\n            }\n            // Fall back to file-based ejection if address is provided\n            else if (walletAddress && password) {\n                const result = await WalletProvider.ejectWalletFromFile(\n                    walletProvider,\n                    walletAddress,\n                    password,\n                );\n                mnemonic = result.mnemonic;\n                address = walletAddress;\n            } else {\n                throw new Error(\n                    'Please provide either a wallet number or both wallet address and password.',\n                );\n            }\n\n            const result = {\n                status: 'success',\n                walletAddress: address,\n                mnemonic,\n                message: `\nWallet ejected successfully.\nYour Decrypted mnemonic is:\\n\\n ${mnemonic}.\nPlease store it securely.`,\n            };\n\n            if (callback) {\n                callback({\n                    text: `Wallet ejected successfully.\\n\\nYour Decrypted mnemonic is:\\n\\n ${mnemonic}.\\n\\nPlease store it securely.`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error ejecting wallet:', error);\n            if (callback) {\n                callback({\n                    text: `Error ejecting wallet: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please eject my Polkadot wallet #1 with password my_password',\n                    action: 'EJECT_POLKADOT_WALLET',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Wallet ejected successfully. Your Decrypted mnemonic is: mnemonic. Please store it securely.',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please eject my Polkadot wallet with address 1234567890 and password my_password',\n                    action: 'EJECT_POLKADOT_WALLET',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Wallet ejected successfully. Your Decrypted mnemonic is: mnemonic. Please store it securely.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { WalletProvider, initWalletProvider, WALLET_CACHE_KEY } from '../providers/wallet';\nimport { stringToU8a, u8aToHex } from '@polkadot/util'; // For message and signature conversion\nimport { z } from 'zod';\nimport type { OptimizedWalletCache } from '../providers/wallet';\n\n// Interface for the content expected by this action\nexport interface SignMessageContent extends Content {\n    messageToSign: string;\n    walletNumber?: number;\n    walletAddress?: string;\n    walletPassword?: string;\n}\n\nexport interface SignMessageResult {\n    status: 'success';\n    signature: string;\n    walletAddress: string;\n    walletNumber: number;\n    message: string;\n}\n\n// Type guard for SignMessageContent\nfunction isSignMessageContent(content: Content): content is SignMessageContent {\n    return typeof (content as SignMessageContent).messageToSign === 'string';\n}\n\n// Zod schema for input validation\nconst signMessageSchema = z.object({\n    messageToSign: z.string().min(1, 'Message to sign cannot be empty.'),\n    walletNumber: z.number().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    walletPassword: z.string().optional().nullable(),\n});\n\n// Template for AI to extract the message\nconst signMessageTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"messageToSign\": \"This is the message I want to sign.\",\n  \"walletNumber\": 1,\n  \"walletAddress\": \"5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\",\n  \"walletPassword\": \"optional-password-if-specified\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\n/**\n * Builds and validates sign message details object using the provided runtime, message, and state.\n */\nexport async function buildSignMessageDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<SignMessageContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const prompt = composePromptFromState({\n        state: currentState,\n        template: signMessageTemplate,\n    });\n\n    const parsedResponse: SignMessageContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as SignMessageContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = signMessageSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid message to sign from the message');\n    }\n\n    return validatedResponse.data as SignMessageContent;\n}\n\nexport class SignMessageAction {\n    private walletProvider: WalletProvider;\n\n    constructor(walletProvider: WalletProvider) {\n        this.walletProvider = walletProvider;\n    }\n\n    async signMessage(\n        messageToSign: string,\n        walletNumber?: number,\n        walletAddress?: string,\n        password?: string,\n    ): Promise<SignMessageResult> {\n        // Validate message is not empty first\n        const messageU8a = stringToU8a(String(messageToSign));\n        if (messageU8a.length === 0) {\n            throw new Error('Cannot sign an empty message');\n        }\n\n        let targetWallet: WalletProvider | null = this.walletProvider;\n        let currentWalletNumber: number | null = null;\n\n        // Try to load by wallet number first\n        if (walletNumber) {\n            targetWallet = await WalletProvider.loadWalletByNumber(\n                this.walletProvider,\n                walletNumber,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet #${walletNumber}. Please check the wallet number.`,\n                );\n            }\n            currentWalletNumber = walletNumber;\n        }\n        // Fall back to loading by address if number fails or address is provided\n        else if (walletAddress) {\n            targetWallet = await WalletProvider.loadWalletByAddress(\n                this.walletProvider,\n                walletAddress,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet with address ${walletAddress}. Please check the address.`,\n                );\n            }\n            // Get wallet number from cache\n            const cache =\n                await targetWallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n            currentWalletNumber = cache?.wallets[walletAddress]?.number || null;\n        }\n\n        const pairs = targetWallet.keyring.getPairs();\n        if (pairs.length === 0) {\n            throw new Error('No key pairs found in the wallet.');\n        }\n\n        // Use the first key pair to sign the message\n        const keypair = pairs[0];\n        const signature = keypair.sign(messageU8a);\n\n        // Store the wallet in cache\n        await WalletProvider.storeWalletInCache(keypair.address, targetWallet);\n\n        return {\n            status: 'success',\n            signature: u8aToHex(signature),\n            walletAddress: keypair.address,\n            walletNumber: currentWalletNumber || 1, // Default to 1 if no number found\n            message: `Message signed successfully. Signature: ${u8aToHex(signature)}`,\n        };\n    }\n}\n\nexport default {\n    name: 'SIGN_POLKADOT_MESSAGE',\n    similes: ['SIGN_MESSAGE', 'SIGN_DATA', 'SIGN_TRANSACTION'],\n    description: 'Signs a message using a Polkadot wallet. Returns the signature.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting SIGN_POLKADOT_MESSAGE action...');\n\n        const signMessageContent = await buildSignMessageDetails(runtime, message, state);\n\n        if (!isSignMessageContent(signMessageContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process sign message request. Please provide a message to sign and either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid sign message request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('signMessageContent', signMessageContent);\n            const { messageToSign, walletNumber, walletAddress } = signMessageContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n            const signAction = new SignMessageAction(walletProvider);\n\n            const result = await signAction.signMessage(\n                String(messageToSign),\n                walletNumber,\n                walletAddress,\n            );\n\n            if (callback) {\n                callback({\n                    text: `Message signed successfully.\\n\\nSignature: ${result.signature}`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error: unknown) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            elizaLogger.error('Error signing message:', errorMessage);\n            if (callback) {\n                callback({\n                    text: `Error signing message: ${errorMessage}`,\n                    content: { error: errorMessage },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Please sign the message 'hello world' with my Polkadot wallet.\",\n                    action: 'SIGN_POLKADOT_MESSAGE',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Message signed successfully!\\nSigner: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\nSignature: 0xabcd1234...',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Can you sign this for me: 'test message 123'\",\n                    action: 'SIGN_POLKADOT_MESSAGE',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Message signed successfully!\\nSigner: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\nSignature: 0xfedc9876...',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\n\n// Interface for the content expected by this action\nexport interface LoadWalletContent extends Content {\n    walletNumber?: number;\n    walletAddress?: string;\n    walletPassword?: string;\n}\n\n// Type guard for LoadWalletContent\nfunction isLoadWalletContent(content: Content): content is LoadWalletContent {\n    return (\n        (typeof content.walletNumber === 'number' ||\n            content.walletNumber === undefined ||\n            content.walletNumber === null) &&\n        (typeof content.walletAddress === 'string' ||\n            content.walletAddress === undefined ||\n            content.walletAddress === null) &&\n        (typeof content.walletPassword === 'string' ||\n            content.walletPassword === undefined ||\n            content.walletPassword === null)\n    );\n}\n\n// Zod schema for input validation\nconst loadWalletSchema = z.object({\n    walletNumber: z.number().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    walletPassword: z.string().optional().nullable(),\n});\n\n// Template for AI to extract the wallet details\nconst loadWalletTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"walletNumber\": 1,\n  \"walletAddress\": \"5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\",\n  \"walletPassword\": \"password\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\n/**\n * Builds and validates load wallet details object using the provided runtime, message, and state.\n */\nexport async function buildLoadWalletDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<LoadWalletContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const prompt = composePromptFromState({\n        state: currentState,\n        template: loadWalletTemplate,\n    });\n\n    const parsedResponse: LoadWalletContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as LoadWalletContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = loadWalletSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid wallet number or address from the message');\n    }\n\n    return parsedResponse;\n}\n\nexport default {\n    name: 'LOAD_POLKADOT_WALLET',\n    similes: ['LOAD_WALLET', 'OPEN_WALLET', 'ACCESS_WALLET'],\n    description:\n        \"Loads an existing Polkadot wallet either by wallet number or address. Returns the wallet's address.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting LOAD_POLKADOT_WALLET action...');\n\n        const loadWalletContent = await buildLoadWalletDetails(runtime, message, state);\n\n        if (!isLoadWalletContent(loadWalletContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process load wallet request. Please provide either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid load wallet request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('loadWalletContent', loadWalletContent);\n            const { walletNumber, walletAddress, walletPassword } = loadWalletContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n\n            let targetWallet: WalletProvider | null = null;\n\n            // Try to load by wallet number first\n            if (walletNumber) {\n                targetWallet = await WalletProvider.loadWalletByNumber(\n                    walletProvider,\n                    walletNumber,\n                    walletPassword,\n                );\n                if (!targetWallet) {\n                    throw new Error(\n                        `Failed to load wallet #${walletNumber}. Please check the wallet number or password.`,\n                    );\n                }\n            }\n            // Fall back to loading by address if number fails or address is provided\n            else if (walletAddress) {\n                targetWallet = await WalletProvider.loadWalletByAddress(\n                    walletProvider,\n                    walletAddress,\n                    walletPassword,\n                );\n                if (!targetWallet) {\n                    throw new Error(\n                        `Failed to load wallet with address ${walletAddress}. Please check the address or password.`,\n                    );\n                }\n            }\n\n            const address = targetWallet.getAddress();\n            const currentWalletNumber = await targetWallet.getWalletNumber();\n\n            // Store the wallet in cache\n            await WalletProvider.storeWalletInCache(address, targetWallet);\n\n            const result = {\n                status: 'success',\n                walletAddress: address,\n                walletNumber: currentWalletNumber,\n                message: `Wallet loaded successfully. Your wallet address is: ${address}${\n                    currentWalletNumber ? ` (Wallet #${currentWalletNumber})` : ''\n                }`,\n            };\n\n            if (callback) {\n                callback({\n                    text: `Wallet loaded successfully.\\n\\nYour wallet address is: ${address}${\n                        currentWalletNumber ? ` (Wallet #${currentWalletNumber})` : ''\n                    }`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error loading wallet:', error);\n            if (callback) {\n                callback({\n                    text: `Error loading wallet: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please load my Polkadot wallet #1 with password my_password',\n                    action: 'LOAD_POLKADOT_WALLET',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Wallet loaded successfully!\\nWallet #1\\nAddress: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\n\\nThe wallet is now ready for use.',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please load my Polkadot wallet with address 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb and password my_password',\n                    action: 'LOAD_POLKADOT_WALLET',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Wallet loaded successfully!\\nWallet #1\\nAddress: 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb\\n\\nThe wallet is now ready for use.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { WALLET_CACHE_KEY, WalletProvider, initWalletProvider } from '../providers/wallet';\nimport type { OptimizedWalletCache } from '../providers/wallet';\nimport { stringToU8a, hexToU8a } from '@polkadot/util';\nimport { z } from 'zod';\n\nexport interface ValidateSignatureContent extends Content {\n    message: string;\n    signature: string;\n    walletNumber?: number;\n    walletPassword?: string;\n    walletAddress?: string;\n}\n\nexport interface ValidateSignatureResult {\n    status: 'success';\n    isValid: boolean;\n    walletAddress: string;\n    walletNumber: number;\n    message: string;\n}\n\n// Zod schema for input validation\nconst validateSignatureSchema = z.object({\n    message: z.string().min(1, 'Message cannot be empty.'),\n    signature: z.string().min(1, 'Signature cannot be empty.'),\n    walletNumber: z.number().optional().nullable(),\n    walletPassword: z.string().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n});\n\n// Template for AI to extract the values\nconst validateSignatureTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\nExample response:\n\\`\\`\\`json\n{\n  \"message\": \"This is the message to verify\",\n  \"signature\": \"0x...\",\n  \"walletNumber\": 1,\n  \"walletPassword\": \"optional-password-if-specified\",\n  \"walletAddress\": \"optional-address-if-specified\"\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nRespond with a JSON markdown block containing only the extracted values`;\n\nexport class ValidateAction {\n    private walletProvider: WalletProvider;\n\n    constructor(walletProvider: WalletProvider) {\n        this.walletProvider = walletProvider;\n    }\n\n    async validateSignature(\n        messageToVerify: string,\n        signature: string,\n        walletNumber?: number,\n        walletAddress?: string,\n        password?: string,\n    ): Promise<ValidateSignatureResult> {\n        if (!walletNumber && !walletAddress) {\n            throw new Error(\n                'Unable to validate signature. Please provide a wallet number or address.',\n            );\n        }\n        // Validate inputs first\n        if (!messageToVerify) {\n            throw new Error('Cannot validate signature for an empty message');\n        }\n        if (!signature) {\n            throw new Error('Cannot validate an empty signature');\n        }\n\n        let targetWallet: WalletProvider | null = this.walletProvider;\n        let currentWalletNumber: number | null = null;\n\n        // Try to load by wallet number first\n        if (walletNumber) {\n            targetWallet = await WalletProvider.loadWalletByNumber(\n                this.walletProvider,\n                walletNumber,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet #${walletNumber}. Please check the wallet number.`,\n                );\n            }\n            currentWalletNumber = walletNumber;\n        }\n        // Fall back to loading by address if number fails or address is provided\n        else if (walletAddress) {\n            targetWallet = await WalletProvider.loadWalletByAddress(\n                this.walletProvider,\n                walletAddress,\n                password,\n            );\n            if (!targetWallet) {\n                throw new Error(\n                    `Failed to load wallet with address ${walletAddress}. Please check the address.`,\n                );\n            }\n            // Get wallet number from cache\n            const cache =\n                await targetWallet.runtime.getCache<OptimizedWalletCache>(WALLET_CACHE_KEY);\n            currentWalletNumber = cache?.wallets[walletAddress]?.number || null;\n        }\n\n        const pairs = targetWallet.keyring.getPairs();\n        if (pairs.length === 0) {\n            throw new Error('No key pairs found in the wallet.');\n        }\n\n        // Use the first key pair to verify the signature\n        const keypair = pairs[0];\n        const messageU8a = stringToU8a(String(messageToVerify));\n        const signatureU8a = hexToU8a(signature);\n        const isValid = keypair.verify(messageU8a, signatureU8a, keypair.publicKey);\n\n        // Store the wallet in cache\n        await WalletProvider.storeWalletInCache(keypair.address, targetWallet);\n\n        return {\n            status: 'success',\n            isValid,\n            walletAddress: keypair.address,\n            walletNumber: currentWalletNumber || 1, // Default to 1 if no number found\n            message: `Signature validation ${isValid ? 'succeeded' : 'failed'}.`,\n        };\n    }\n}\n\n/**\n * Builds and validates signature verification details object using the provided runtime, message, and state.\n */\nexport async function buildValidateSignatureDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<ValidateSignatureContent> {\n    const currentState = state || (await runtime.composeState(message));\n    const prompt = composePromptFromState({\n        state: currentState,\n        template: validateSignatureTemplate,\n    });\n\n    const parsedResponse: ValidateSignatureContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as ValidateSignatureContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    if (!parsedResponse) {\n        throw new Error('Failed to extract a valid validate signature details from the message');\n    }\n\n    //zod validate the response\n    const validatedResponse = validateSignatureSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid validate signature details from the message');\n    }\n\n    return validatedResponse.data as ValidateSignatureContent;\n}\n\n// Type guard for validate signature content\nconst isValidateSignatureContent = (content: unknown): content is ValidateSignatureContent => {\n    return (\n        typeof content === 'object' &&\n        content !== null &&\n        'message' in content &&\n        'signature' in content &&\n        (('walletNumber' in content && typeof content.walletNumber === 'number') ||\n            ('walletAddress' in content && typeof content.walletAddress === 'string'))\n    );\n};\n\nexport default {\n    name: 'VALIDATE_POLKADOT_SIGNATURE',\n    similes: ['VERIFY_SIGNATURE', 'CHECK_SIGNATURE', 'VALIDATE_SIGNATURE'],\n    description:\n        'Validates a signature for a message using a Polkadot wallet. Returns whether the signature is valid.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting VALIDATE_POLKADOT_SIGNATURE action...');\n\n        const validateSignatureContent = await buildValidateSignatureDetails(\n            runtime,\n            message,\n            state,\n        );\n\n        if (!isValidateSignatureContent(validateSignatureContent)) {\n            if (callback) {\n                callback({\n                    text: 'Unable to process validate signature request. Please provide a message, signature, and either a wallet number or wallet address.',\n                    content: {\n                        error: 'Invalid validate signature request. Missing required parameters.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            elizaLogger.debug('validateSignatureContent', validateSignatureContent);\n            const {\n                message: messageToVerify,\n                signature,\n                walletNumber,\n                walletAddress,\n            } = validateSignatureContent;\n\n            // Initialize the wallet provider\n            const walletProvider = await initWalletProvider(runtime);\n            const validateAction = new ValidateAction(walletProvider);\n\n            const result = await validateAction.validateSignature(\n                messageToVerify,\n                signature,\n                walletNumber,\n                walletAddress,\n            );\n\n            if (callback) {\n                callback({\n                    text: result.message,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error validating signature:', error);\n            if (callback) {\n                callback({\n                    text: `Error validating signature: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Please verify this signature: 0x1234... for message 'hello world'\",\n                    action: 'VALIDATE_POLKADOT_SIGNATURE',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Signature is valid for address 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Check if signature 0x5678... is valid for message 'test' using wallet #1\",\n                    action: 'VALIDATE_POLKADOT_SIGNATURE',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Signature is valid for address 5GrwvaEF5zXb26FfGZWvt2fBvXN1Jz2yXzL9Vvns8wQMXwXb',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { z } from 'zod';\nimport { formatBalance } from '@polkadot/util';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetBalanceContent extends Content {\n    address: string;\n}\n\nexport const getBalanceSchema = z.object({\n    address: z.string().min(1, 'Address is required'),\n});\n\nexport const addressTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"address\": \"15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetBalanceDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<GetBalanceContent> {\n    const prompt = composePromptFromState({\n        state,\n        template: addressTemplate,\n    });\n\n    const parsedResponse: GetBalanceContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as GetBalanceContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = getBalanceSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid Polkadot address from the message');\n    }\n\n    return validatedResponse.data as GetBalanceContent;\n}\n\nexport class GetBalanceAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getBalance(params: { address: string }): Promise<{\n        address: string;\n        freeBalance: string;\n        reservedBalance: string;\n        totalBalance: string;\n        formattedFreeBalance: string;\n        formattedReservedBalance: string;\n        formattedTotalBalance: string;\n        tokenSymbol: string;\n        tokenDecimals: number;\n    }> {\n        try {\n            elizaLogger.debug('Initializing getBalance for address:', params.address);\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n            elizaLogger.debug('API connection established');\n\n            const accountInfo = await api.query.system.account(params.address);\n            elizaLogger.debug('Account info retrieved:', accountInfo.toHuman());\n            const balance = accountInfo.toJSON() as { data: { free: string; reserved: string } };\n\n            const properties = await api.rpc.system.properties();\n            elizaLogger.debug('Chain properties retrieved:', properties.toHuman());\n            const tokenSymbol = properties.tokenSymbol.unwrap()[0].toString();\n            const tokenDecimals = properties.tokenDecimals.unwrap()[0].toNumber();\n            elizaLogger.debug('Token details:', { tokenSymbol, tokenDecimals });\n\n            formatBalance.setDefaults({\n                decimals: tokenDecimals,\n                unit: tokenSymbol,\n            });\n\n            const formatOptions = {\n                withSi: false,\n                forceUnit: tokenSymbol,\n            };\n\n            const freeBalance = balance.data.free.toString();\n            const reservedBalance = balance.data.reserved.toString();\n            const totalBalance = (\n                BigInt(balance.data.free) + BigInt(balance.data.reserved)\n            ).toString();\n            elizaLogger.debug('Balance calculations completed:', {\n                freeBalance,\n                reservedBalance,\n                totalBalance,\n            });\n\n            const formattedFreeBalance = `${formatBalance(\n                balance.data.free,\n                formatOptions,\n            )} ${tokenSymbol}`;\n            const formattedReservedBalance = `${formatBalance(\n                balance.data.reserved,\n                formatOptions,\n            )} ${tokenSymbol}`;\n            const formattedTotalBalance = `${formatBalance(\n                BigInt(balance.data.free) + BigInt(balance.data.reserved),\n                formatOptions,\n            )} ${tokenSymbol}`;\n            elizaLogger.debug('Formatted balances:', {\n                formattedFreeBalance,\n                formattedReservedBalance,\n                formattedTotalBalance,\n            });\n\n            return {\n                address: params.address,\n                freeBalance,\n                reservedBalance,\n                totalBalance,\n                formattedFreeBalance,\n                formattedReservedBalance,\n                formattedTotalBalance,\n                tokenSymbol,\n                tokenDecimals,\n            };\n        } catch (error) {\n            elizaLogger.error(`Error fetching balance for address ${params.address}:`, error);\n            throw new Error(`Failed to retrieve balance: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_POLKADOT_BALANCE',\n    similes: ['CHECK_POLKADOT_BALANCE', 'VIEW_POLKADOT_BALANCE', 'POLKADOT_BALANCE'],\n    description:\n        'Retrieves the balance information for a Polkadot address, including free, reserved, and total balances.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_POLKADOT_BALANCE action...');\n\n        try {\n            const getBalanceContent = await buildGetBalanceDetails(runtime, message, state);\n\n            elizaLogger.debug('getBalanceContent', getBalanceContent);\n\n            if (!getBalanceContent || typeof getBalanceContent.address !== 'string') {\n                elizaLogger.error('Failed to obtain a valid address.');\n                if (callback) {\n                    callback({\n                        text: \"I couldn't process your balance request. Please provide a valid Polkadot address.\",\n                        content: { error: 'Invalid address format or missing address.' },\n                    });\n                }\n                return false;\n            }\n\n            const action = new GetBalanceAction(runtime);\n            const balanceInfo = await action.getBalance({\n                address: getBalanceContent.address,\n            });\n\n            const userMessageText = `\nBalance Information for: ${balanceInfo.address}\n\nFree Balance: ${balanceInfo.formattedFreeBalance}\nReserved Balance: ${balanceInfo.formattedReservedBalance}\nTotal Balance: ${balanceInfo.formattedTotalBalance}\n\nNote: Free balance is the amount available for transfers and transactions. Reserved balance is locked for various on-chain activities.`;\n\n            const result = {\n                status: 'success',\n                address: balanceInfo.address,\n                freeBalance: balanceInfo.freeBalance,\n                reservedBalance: balanceInfo.reservedBalance,\n                totalBalance: balanceInfo.totalBalance,\n                formattedFreeBalance: balanceInfo.formattedFreeBalance,\n                formattedReservedBalance: balanceInfo.formattedReservedBalance,\n                formattedTotalBalance: balanceInfo.formattedTotalBalance,\n                tokenSymbol: balanceInfo.tokenSymbol,\n                tokenDecimals: balanceInfo.tokenDecimals,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving balance:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving balance: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'What is the balance of 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz?',\n                    action: 'GET_POLKADOT_BALANCE',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Balance Information for: 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz\\n\\nFree Balance: 10.5000 DOT\\nReserved Balance: 0.0000 DOT\\nTotal Balance: 10.5000 DOT\\n\\nNote: Free balance is the amount available for transfers and transactions. Reserved balance is locked for various on-chain activities.',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Check the DOT balance in this address: 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz',\n                    action: 'GET_POLKADOT_BALANCE',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Balance Information for: 15JRT5GjLAZkuvmpwmjCUp1RRLr7Y6Gnusz37ia37h2Xn5Rz\\n\\nFree Balance: 10.5000 DOT\\nReserved Balance: 0.0000 DOT\\nTotal Balance: 10.5000 DOT\\n\\nNote: Free balance is the amount available for transfers and transactions. Reserved balance is locked for various on-chain activities.',\n                },\n            },\n        ],\n    ],\n};\n","import { elizaLogger } from '@elizaos/core';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Service, IAgentRuntime } from '@elizaos/core';\n\nconst DEFAULT_NETWORK_CONFIG = {\n    DEFAULT_ENDPOINT: 'wss://rpc.polkadot.io',\n    BACKUP_ENDPOINTS: [\n        'wss://polkadot-rpc.dwellir.com',\n        'wss://polkadot.api.onfinality.io/public-ws',\n        'wss://rpc.ibp.network/polkadot',\n        'wss://polkadot-rpc.publicnode.com',\n    ],\n    MAX_RETRIES: 3,\n    RETRY_DELAY: 2000,\n};\n\n/**\n * Singleton service that manages connection to the Polkadot API\n * Includes connection pooling, retry logic, and endpoint fallback\n */\nexport class PolkadotApiService extends Service {\n    static serviceType = 'polkadot_api' as const;\n    capabilityDescription = 'The agent is able to interact with the Polkadot API';\n\n    private static _instance: PolkadotApiService | null = null;\n    private api: ApiPromise | null = null;\n    private provider: WsProvider | null = null;\n    private connecting = false;\n    private connectionPromise: Promise<ApiPromise> | null = null;\n    private lastEndpointIndex = 0;\n    private networkConfig = { ...DEFAULT_NETWORK_CONFIG };\n\n    constructor(protected runtime: IAgentRuntime) {\n        super();\n    }\n\n    static async start(runtime: IAgentRuntime): Promise<PolkadotApiService> {\n        if (!PolkadotApiService._instance) {\n            PolkadotApiService._instance = new PolkadotApiService(runtime);\n            await PolkadotApiService._instance.initialize();\n            await PolkadotApiService._instance.connectWithRetry();\n        }\n        return PolkadotApiService._instance;\n    }\n\n    async stop(): Promise<void> {\n        await this.disconnect();\n        PolkadotApiService._instance = null;\n    }\n\n    async initialize(): Promise<void> {\n        const customEndpoint = this.runtime.getSetting('POLKADOT_RPC_URL');\n\n        if (customEndpoint) {\n            this.networkConfig.DEFAULT_ENDPOINT = customEndpoint;\n            elizaLogger.debug(`Using custom Polkadot endpoint: ${customEndpoint}`);\n        } else {\n            elizaLogger.debug(\n                `No custom endpoint found, using default: ${this.networkConfig.DEFAULT_ENDPOINT}`,\n            );\n        }\n    }\n\n    /**\n     * Get a connection to the Polkadot API\n     * If a connection is already established, it will be reused\n     * If no connection exists, a new one will be created\n     * If a connection is being established, the existing promise will be returned\n     */\n    public async getConnection(): Promise<ApiPromise> {\n        if (this.api?.isConnected) {\n            return this.api;\n        }\n\n        if (this.connecting && this.connectionPromise) {\n            return this.connectionPromise;\n        }\n\n        this.connecting = true;\n        this.connectionPromise = this.connectWithRetry();\n\n        try {\n            this.api = await this.connectionPromise;\n            return this.api;\n        } finally {\n            this.connecting = false;\n            this.connectionPromise = null;\n        }\n    }\n\n    /**\n     * Connect to the Polkadot API with retry logic\n     * @param retryCount Current retry attempt number\n     */\n    private async connectWithRetry(retryCount = 0): Promise<ApiPromise> {\n        try {\n            const endpoint = this.getNextEndpoint();\n            elizaLogger.debug(`Connecting to Polkadot at ${endpoint}`);\n\n            this.provider = new WsProvider(endpoint);\n            this.api = await ApiPromise.create({ provider: this.provider });\n\n            elizaLogger.debug(`Connected to Polkadot at ${endpoint}`);\n            return this.api;\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`Polkadot connection error: ${message}`);\n\n            if (retryCount < this.networkConfig.MAX_RETRIES) {\n                const delay = this.networkConfig.RETRY_DELAY * 2 ** retryCount;\n                elizaLogger.debug(`Retrying connection in ${delay}ms...`);\n\n                await new Promise((resolve) => setTimeout(resolve, delay));\n                return this.connectWithRetry(retryCount + 1);\n            }\n\n            throw new Error(\n                `Failed to connect to Polkadot after ${this.networkConfig.MAX_RETRIES} attempts`,\n            );\n        }\n    }\n\n    /**\n     * Get the next endpoint to try from the configured endpoints\n     * This implements a round-robin selection strategy\n     */\n    private getNextEndpoint(): string {\n        const allEndpoints = [\n            this.networkConfig.DEFAULT_ENDPOINT,\n            ...this.networkConfig.BACKUP_ENDPOINTS,\n        ];\n        this.lastEndpointIndex = this.lastEndpointIndex % allEndpoints.length;\n        elizaLogger.debug(`Next endpoint: ${allEndpoints[this.lastEndpointIndex]}`);\n        return allEndpoints[this.lastEndpointIndex];\n    }\n\n    /**\n     * Disconnect from the Polkadot API\n     * This should be called when the application is shutting down\n     */\n    public async disconnect(): Promise<void> {\n        if (this.api) {\n            await this.api.disconnect();\n            this.api = null;\n        }\n\n        if (this.provider) {\n            this.provider.disconnect();\n            this.provider = null;\n        }\n    }\n\n    /**\n     * Check if a connection is currently established\n     */\n    public isConnected(): boolean {\n        return !!this.api && this.api.isConnected;\n    }\n\n    /**\n     * Get information about the current connection\n     * Returns null if no connection is established\n     */\n    public getConnectionInfo(): { endpoint: string; connected: boolean } | null {\n        if (!this.provider) {\n            return null;\n        }\n\n        return {\n            endpoint: this.provider.endpoint,\n            connected: this.isConnected(),\n        };\n    }\n\n    /**\n     * Set custom endpoints for the API connection\n     * This allows endpoints to be configured at runtime\n     * @param endpoints Array of WebSocket endpoints\n     */\n    public setCustomEndpoints(endpoints: string[]): void {\n        if (!endpoints || endpoints.length === 0) {\n            return;\n        }\n\n        // Only update if there's at least one valid endpoint\n        if (endpoints.some((e) => e.startsWith('wss://') || e.startsWith('ws://'))) {\n            // Replace the existing configuration\n            Object.defineProperty(this.networkConfig, 'DEFAULT_ENDPOINT', {\n                value: endpoints[0],\n                writable: true,\n            });\n\n            Object.defineProperty(this.networkConfig, 'BACKUP_ENDPOINTS', {\n                value: endpoints.slice(1),\n                writable: true,\n            });\n\n            // Reset the endpoint index\n            this.lastEndpointIndex = 0;\n            elizaLogger.debug(`Updated Polkadot API endpoints: ${endpoints.join(', ')}`);\n        }\n    }\n}\n\nexport default PolkadotApiService;\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetBlockInfoContent extends Content {\n    blockNumberOrHash: string;\n}\n\n// Define proper types for API responses\ninterface PolkadotBlock {\n    block: {\n        header: {\n            number: { toString: () => string };\n            parentHash: { toString: () => string };\n            stateRoot: { toString: () => string };\n            extrinsicsRoot: { toString: () => string };\n        };\n        extrinsics: { toArray: () => unknown[] };\n    };\n}\n\ninterface PolkadotTimestamp {\n    toNumber: () => number;\n}\n\ninterface PolkadotEvents {\n    toJSON: () => unknown[];\n}\n\nexport const blockInfoSchema = z.object({\n    blockNumberOrHash: z.string().min(1, 'Block number or hash is required'),\n});\n\nexport const blockInfoTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"12345678\" \n  }\n  \\`\\`\\`\n  or\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"0x1a2b3c4d5e6f...\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetBlockInfoDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<GetBlockInfoContent> {\n    const prompt = composePromptFromState({\n        state,\n        template: blockInfoTemplate,\n    });\n\n    const parsedResponse: GetBlockInfoContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as GetBlockInfoContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = blockInfoSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid block number or hash from the message');\n    }\n\n    return validatedResponse.data as GetBlockInfoContent;\n}\n\n// Helper function to format timestamp\nfunction formatTimestamp(timestamp: string): string {\n    if (timestamp === 'Unknown') {\n        return 'Unknown';\n    }\n\n    try {\n        const date = new Date(timestamp);\n        return `${date.toISOString().replace('T', ' ').slice(0, 19)} UTC`;\n    } catch {\n        return timestamp;\n    }\n}\n\nexport class GetBlockInfoAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getBlockInfo(params: { blockNumberOrHash: string }): Promise<{\n        number: string;\n        hash: string;\n        parentHash: string;\n        stateRoot: string;\n        extrinsicsRoot: string;\n        timestamp: string;\n        extrinsicsCount: number;\n        eventsCount: number;\n    }> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n            let blockHash: string;\n            if (params.blockNumberOrHash.startsWith('0x')) {\n                // This is a hash\n                blockHash = params.blockNumberOrHash;\n            } else {\n                // This is a block number\n                const hashResult = await api.rpc.chain.getBlockHash(\n                    parseInt(params.blockNumberOrHash),\n                );\n                blockHash = hashResult.toString();\n            }\n\n            // Get block with extended data\n            const [blockResult, eventsResult, timestampResult] = await Promise.allSettled([\n                api.rpc.chain.getBlock(blockHash),\n                api.query.system.events.at(blockHash),\n                api.query.timestamp?.now\n                    ? api.query.timestamp.now.at(blockHash)\n                    : Promise.resolve(null),\n            ]);\n\n            if (blockResult.status === 'rejected') {\n                throw blockResult.reason;\n            }\n            if (eventsResult.status === 'rejected') {\n                throw eventsResult.reason;\n            }\n\n            const signedBlock = blockResult.value as unknown as PolkadotBlock;\n            const eventsRaw = eventsResult.value as unknown as PolkadotEvents;\n            const timestamp = timestampResult.status === 'fulfilled' ? timestampResult.value : null;\n\n            const block = signedBlock.block;\n            const blockNumber = block.header.number.toString();\n\n            // Convert events to proper format first with proper typing\n            const events = eventsRaw.toJSON() as unknown[];\n\n            // Extract block data\n            const blockInfo = {\n                number: blockNumber,\n                hash: blockHash.toString(),\n                parentHash: block.header.parentHash.toString(),\n                stateRoot: block.header.stateRoot.toString(),\n                extrinsicsRoot: block.header.extrinsicsRoot.toString(),\n                timestamp:\n                    timestamp !== null && timestamp !== undefined\n                        ? new Date(\n                              (timestamp as unknown as PolkadotTimestamp).toNumber(),\n                          ).toISOString()\n                        : 'Unknown',\n                extrinsicsCount: block.extrinsics.toArray().length, // Convert to array first\n                eventsCount: Array.isArray(events) ? events.length : 0,\n            };\n\n            return blockInfo;\n        } catch (error) {\n            elizaLogger.error(`Error fetching block info for ${params.blockNumberOrHash}:`, error);\n            throw new Error(`Failed to retrieve block info: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_BLOCK_INFO',\n    similes: ['VIEW_BLOCK_INFO', 'BLOCK_DETAILS', 'POLKADOT_BLOCK_INFO'],\n    description: 'Retrieves detailed information about a Polkadot block by its number or hash.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_BLOCK_INFO action...');\n\n        try {\n            const getBlockInfoContent = await buildGetBlockInfoDetails(runtime, message, state);\n\n            elizaLogger.debug('getBlockInfoContent', getBlockInfoContent);\n\n            if (!getBlockInfoContent || typeof getBlockInfoContent.blockNumberOrHash !== 'string') {\n                elizaLogger.error('Failed to obtain a valid block number or hash.');\n                if (callback) {\n                    callback({\n                        text: \"I couldn't process your block info request. Please provide a valid block number or hash.\",\n                        content: { error: 'Invalid block number or hash format.' },\n                    });\n                }\n                return false;\n            }\n\n            const action = new GetBlockInfoAction(runtime);\n            const blockInfo = await action.getBlockInfo({\n                blockNumberOrHash: getBlockInfoContent.blockNumberOrHash,\n            });\n\n            const timeInfo =\n                blockInfo.timestamp !== 'Unknown'\n                    ? `\\nâ° Time: ${formatTimestamp(blockInfo.timestamp)}`\n                    : '';\n\n            const userMessageText = `\nðŸ“¦ Block ${blockInfo.number} Information\n\nBasic Details:\nâ€¢ Number: ${blockInfo.number}\nâ€¢ Hash: ${blockInfo.hash}\nâ€¢ Parent: ${blockInfo.parentHash}${timeInfo}\n\nMerkle Roots:\nâ€¢ State Root: ${blockInfo.stateRoot}\nâ€¢ Extrinsics Root: ${blockInfo.extrinsicsRoot}\n\nBlock Content:\nâ€¢ ðŸ“‹ Extrinsics: ${blockInfo.extrinsicsCount}\nâ€¢ ðŸ“ Events: ${blockInfo.eventsCount}\n\nðŸ“Š This block processed ${blockInfo.extrinsicsCount} transaction${\n                blockInfo.extrinsicsCount === 1 ? '' : 's'\n            } and generated ${blockInfo.eventsCount} event${\n                blockInfo.eventsCount === 1 ? '' : 's'\n            }.`;\n\n            const result = {\n                status: 'success',\n                number: blockInfo.number,\n                hash: blockInfo.hash,\n                parentHash: blockInfo.parentHash,\n                stateRoot: blockInfo.stateRoot,\n                extrinsicsRoot: blockInfo.extrinsicsRoot,\n                timestamp: blockInfo.timestamp,\n                extrinsicsCount: blockInfo.extrinsicsCount,\n                eventsCount: blockInfo.eventsCount,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving block info:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving block info: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"What's the information for block 12345678?\",\n                    action: 'GET_BLOCK_INFO',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block 12345678 Information\\n\\nBasic Details:\\nâ€¢ Number: 12345678\\nâ€¢ Hash: 0x8d7c0cce1768da5c...\\nâ€¢ Parent: 0x557be0d61c75e187...\\nâ° Time: 2023-06-15 12:34:56 UTC\\n\\nMerkle Roots:\\nâ€¢ State Root: 0x7b8f01096c356d77...\\nâ€¢ Extrinsics Root: 0x8a65db1f6cc5a7e5...\\n\\nBlock Content:\\nâ€¢ ðŸ“‹ Extrinsics: 3\\nâ€¢ ðŸ“ Events: 8\\n\\nðŸ“Š This block processed 3 transactions and generated 8 events.',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Show me the details of block 0x8d7c0cce1768da5c1725def400ce1a337369cbba4c4844d6f9b8bab255c9bb07',\n                    action: 'GET_BLOCK_INFO',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block 12345678 Information\\n\\nBasic Details:\\nâ€¢ Number: 12345678\\nâ€¢ Hash: 0x8d7c0cce1768da5c...\\nâ€¢ Parent: 0x557be0d61c75e187...\\nâ° Time: 2023-06-15 12:34:56 UTC\\n\\nMerkle Roots:\\nâ€¢ State Root: 0x7b8f01096c356d77...\\nâ€¢ Extrinsics Root: 0x8a65db1f6cc5a7e5...\\n\\nBlock Content:\\nâ€¢ ðŸ“‹ Extrinsics: 3\\nâ€¢ ðŸ“ Events: 8\\n\\nðŸ“Š This block processed 3 transactions and generated 8 events.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { PolkadotApiService } from '../services/api-service';\nimport { z } from 'zod';\n\nexport interface GetBlockEventsContent extends Content {\n    blockNumberOrHash: string;\n    filterModule?: string;\n    limit?: number;\n}\n\nexport interface BlockEvent {\n    index: number;\n    section: string;\n    method: string;\n    dataCount: number;\n    phase: string;\n    summary: string;\n}\n\ninterface EventData {\n    [key: string]: unknown;\n}\n\n// Use a more flexible approach for Polkadot Codec types\ninterface PolkadotEvent {\n    section: { toString(): string };\n    method: { toString(): string };\n    data: { toJSON(): EventData[] };\n}\n\ninterface PolkadotPhase {\n    isApplyExtrinsic?: boolean;\n    asApplyExtrinsic?: { toString(): string };\n    isFinalization?: boolean;\n    isInitialization?: boolean;\n    type?: string;\n}\n\n// Use unknown for the complex Polkadot API types, then type guard them\ninterface EventRecord {\n    event: unknown;\n    phase: unknown;\n}\n\nexport const blockEventsSchema = z.object({\n    blockNumberOrHash: z.string().min(1, 'Block number or hash is required'),\n    filterModule: z\n        .string()\n        .optional()\n        .nullable()\n        .transform((val) => (val === 'null' || val === null ? undefined : val)),\n    limit: z\n        .union([z.number(), z.string()])\n        .optional()\n        .nullable()\n        .transform((val) => {\n            if (val === 'null' || val === null || val === undefined) return undefined;\n            const num = typeof val === 'string' ? parseInt(val) : val;\n            return Number.isNaN(num) ? undefined : Math.min(Math.max(num, 1), 1000);\n        }),\n});\n\nexport const blockEventsTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  \n  Extract the block number or hash from the message. Optionally extract a module filter (like \"balances\", \"system\", \"staking\") and a limit for the number of events.\n  \n  IMPORTANT: \n  - For filterModule: use the actual module name if specified, or omit the field entirely if not mentioned\n  - For limit: use the actual number if specified, or omit the field entirely if not mentioned\n  - Do NOT use the string \"null\" - either include the field with a value or omit it entirely\n  \n  Example response:\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"12345678\",\n    \"filterModule\": \"balances\",\n    \"limit\": 50\n  }\n  \\`\\`\\`\n  or\n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"0x1a2b3c4d5e6f...\"\n  }\n  \\`\\`\\`\n  or \n  \\`\\`\\`json\n  {\n    \"blockNumberOrHash\": \"12345678\",\n    \"limit\": 10\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetBlockEventsDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<GetBlockEventsContent> {\n    //compose the prompt\n    const prompt = composePromptFromState({\n        state,\n        template: blockEventsTemplate,\n    });\n\n    //use the model to get the response\n    const parsedResponse: GetBlockEventsContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as GetBlockEventsContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = blockEventsSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid block number or hash from the message');\n    }\n\n    return validatedResponse.data as GetBlockEventsContent;\n}\n\n// Helper function to create a readable summary for different event types\nfunction createEventSummary(section: string, method: string, data: EventData[]): string {\n    const eventKey = `${section}.${method}`;\n\n    switch (eventKey) {\n        case 'balances.Transfer':\n            if (data.length >= 3) {\n                return `${data[0]} â†’ ${data[1]} (${data[2]} units)`;\n            }\n            break;\n        case 'balances.Deposit':\n            if (data.length >= 2) {\n                return `${data[0]} (+${data[1]} units)`;\n            }\n            break;\n        case 'system.ExtrinsicSuccess':\n            return 'Extrinsic executed successfully';\n        case 'system.ExtrinsicFailed':\n            return 'Extrinsic failed';\n        case 'staking.Reward':\n            if (data.length >= 2) {\n                return `${data[0]} rewarded ${data[1]} units`;\n            }\n            break;\n        case 'democracy.Proposed':\n            return 'New proposal created';\n        case 'democracy.Voted':\n            return 'Vote cast';\n        case 'treasury.Deposit':\n            if (data.length >= 1) {\n                return `Treasury deposit: ${data[0]} units`;\n            }\n            break;\n        default:\n            // For unknown events, just show the count of data items\n            if (data.length === 0) {\n                return 'No data';\n            }\n            if (data.length === 1) {\n                return '1 data item';\n            }\n            return `${data.length} data items`;\n    }\n\n    return data.length === 0 ? 'No data' : `${data.length} data items`;\n}\n\nexport class GetBlockEventsAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getBlockEvents(params: {\n        blockNumberOrHash: string;\n        filterModule?: string;\n        limit?: number;\n    }): Promise<{\n        blockNumber: string;\n        blockHash: string;\n        totalEvents: number;\n        filteredEvents: number;\n        events: BlockEvent[];\n        filterApplied?: string;\n        limitApplied?: number;\n    }> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n\n            let blockHash: string;\n            let blockNumber: string;\n\n            if (params.blockNumberOrHash.startsWith('0x')) {\n                // This is a hash\n                blockHash = params.blockNumberOrHash;\n                const header = await api.rpc.chain.getHeader(blockHash);\n                blockNumber = header.number.toString();\n            } else {\n                // This is a block number\n                blockNumber = params.blockNumberOrHash;\n                blockHash = (await api.rpc.chain.getBlockHash(parseInt(blockNumber))).toString();\n            }\n\n            // Get events for the block - use unknown to handle Codec type\n            const eventsAtBlock = await api.query.system.events.at(blockHash);\n\n            // Convert Codec to array - use unknown first, then cast to iterable\n            const eventsArray = Array.from(eventsAtBlock as unknown as Iterable<EventRecord>);\n            let processedEvents: BlockEvent[] = eventsArray.map(\n                (eventRecord: EventRecord, index) => {\n                    // Type guard and extract event details\n                    const event = eventRecord.event as PolkadotEvent;\n                    const phase = eventRecord.phase as PolkadotPhase;\n\n                    // Extract event details using the codec methods\n                    const section = event.section.toString();\n                    const method = event.method.toString();\n                    const data = event.data.toJSON() as EventData[];\n\n                    // Determine phase description\n                    let phaseDesc = 'Unknown';\n                    try {\n                        if (phase.isApplyExtrinsic) {\n                            phaseDesc = `Extrinsic ${\n                                phase.asApplyExtrinsic?.toString() || 'Unknown'\n                            }`;\n                        } else if (phase.isFinalization) {\n                            phaseDesc = 'Finalization';\n                        } else if (phase.isInitialization) {\n                            phaseDesc = 'Initialization';\n                        } else {\n                            phaseDesc = phase.type || 'Unknown';\n                        }\n                    } catch {\n                        phaseDesc = 'Unknown';\n                    }\n\n                    // Create a readable summary instead of showing raw data\n                    const summary = createEventSummary(section, method, data);\n\n                    return {\n                        index,\n                        section,\n                        method,\n                        dataCount: data.length,\n                        phase: phaseDesc,\n                        summary,\n                    };\n                },\n            );\n\n            const totalEvents = processedEvents.length;\n\n            // Apply module filter if specified\n            if (params.filterModule) {\n                processedEvents = processedEvents.filter(\n                    (event) => event.section.toLowerCase() === params.filterModule?.toLowerCase(),\n                );\n            }\n\n            const filteredEvents = processedEvents.length;\n\n            // Apply limit if specified\n            if (params.limit && params.limit < processedEvents.length) {\n                processedEvents = processedEvents.slice(0, params.limit);\n            }\n\n            return {\n                blockNumber,\n                blockHash: blockHash.toString(),\n                totalEvents,\n                filteredEvents,\n                events: processedEvents,\n                filterApplied: params.filterModule,\n                limitApplied: params.limit,\n            };\n        } catch (error) {\n            elizaLogger.error(\n                `Error fetching events for block ${params.blockNumberOrHash}:`,\n                error,\n            );\n            throw new Error(`Failed to retrieve block events: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_BLOCK_EVENTS',\n    similes: ['VIEW_BLOCK_EVENTS', 'BLOCK_EVENTS', 'POLKADOT_EVENTS', 'GET_EVENTS'],\n    description:\n        'Retrieves all events that occurred in a specific Polkadot block, with optional filtering by module and limiting.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_BLOCK_EVENTS action...');\n\n        try {\n            const getBlockEventsContent = await buildGetBlockEventsDetails(runtime, message, state);\n\n            elizaLogger.debug('getBlockEventsContent', getBlockEventsContent);\n\n            if (\n                !getBlockEventsContent ||\n                typeof getBlockEventsContent.blockNumberOrHash !== 'string'\n            ) {\n                elizaLogger.error('Failed to obtain a valid block number or hash.');\n                if (callback) {\n                    callback({\n                        text: \"I couldn't process your block events request. Please provide a valid block number or hash.\",\n                        content: { error: 'Invalid block number or hash format.' },\n                    });\n                }\n                return false;\n            }\n\n            const action = new GetBlockEventsAction(runtime);\n            const eventsInfo = await action.getBlockEvents({\n                blockNumberOrHash: getBlockEventsContent.blockNumberOrHash,\n                filterModule: getBlockEventsContent.filterModule,\n                limit: getBlockEventsContent.limit,\n            });\n\n            // Format events for display - cleaner formatting\n            const eventsDisplay = eventsInfo.events\n                .map((event, idx) => {\n                    return `${idx + 1}. ${event.section}.${event.method} (${event.phase})\\n   â””â”€ ${\n                        event.summary\n                    }`;\n                })\n                .join('\\n');\n\n            const showingText =\n                eventsInfo.events.length < eventsInfo.filteredEvents\n                    ? ` (showing first ${eventsInfo.events.length})`\n                    : '';\n\n            const filterText = eventsInfo.filterApplied\n                ? `\\nFilter: ${eventsInfo.filterApplied} module events only`\n                : '';\n\n            const moreEventsText =\n                eventsInfo.events.length < eventsInfo.filteredEvents\n                    ? `\\n\\nðŸ“‹ ${\n                          eventsInfo.filteredEvents - eventsInfo.events.length\n                      } more events available. Use a higher limit to see more.`\n                    : '';\n\n            const userMessageText = `\nðŸ“¦ Block Events for Block ${eventsInfo.blockNumber}\nHash: ${eventsInfo.blockHash.slice(0, 20)}...\n\nSummary:\nâ€¢ Total Events: ${eventsInfo.totalEvents}\nâ€¢ Filtered Events: ${eventsInfo.filteredEvents}${showingText}${filterText}\n\n${\n    eventsInfo.events.length > 0\n        ? `Events:\\n${eventsDisplay}${moreEventsText}`\n        : 'âŒ No events found with the applied filters.'\n}`;\n\n            const result = {\n                status: 'success',\n                blockNumber: eventsInfo.blockNumber,\n                blockHash: eventsInfo.blockHash,\n                totalEvents: eventsInfo.totalEvents,\n                filteredEvents: eventsInfo.filteredEvents,\n                events: eventsInfo.events,\n                filterApplied: eventsInfo.filterApplied,\n                limitApplied: eventsInfo.limitApplied,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving block events:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving block events: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'What events happened in block 12345678?',\n                    action: 'GET_BLOCK_EVENTS',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block Events for Block 12345678\\nHash: 0x8d7c0cce1768da5c...\\n\\nSummary:\\nâ€¢ Total Events: 8\\nâ€¢ Filtered Events: 8 (showing first 5)\\n\\nEvents:\\n1. system.ExtrinsicSuccess (Extrinsic 1)\\n   â””â”€ Extrinsic executed successfully\\n\\n2. balances.Transfer (Extrinsic 2)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY â†’ 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty (10000000000 units)\\n\\n3. system.ExtrinsicSuccess (Extrinsic 2)\\n   â””â”€ Extrinsic executed successfully\\n\\n4. treasury.Deposit (Finalization)\\n   â””â”€ Treasury deposit: 1000000000 units\\n\\n5. balances.Deposit (Finalization)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY (+500000000 units)\\n\\nðŸ“‹ 3 more events available. Use a higher limit to see more.',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Show me only the balances events from block 0x8d7c0cce1768da5c1725def400ce1a337369cbba4c4844d6f9b8bab255c9bb07',\n                    action: 'GET_BLOCK_EVENTS',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block Events for Block 12345678\\nHash: 0x8d7c0cce1768da5c...\\n\\nSummary:\\nâ€¢ Total Events: 8\\nâ€¢ Filtered Events: 3\\nFilter: balances module events only\\n\\nEvents:\\n1. balances.Transfer (Extrinsic 2)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY â†’ 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty (10000000000 units)\\n\\n2. balances.Deposit (Finalization)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY (+500000000 units)\\n\\n3. balances.Reserved (Finalization)\\n   â””â”€ 2 data items',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Get the first 3 events from block 12345678',\n                    action: 'GET_BLOCK_EVENTS',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ“¦ Block Events for Block 12345678\\nHash: 0x8d7c0cce1768da5c...\\n\\nSummary:\\nâ€¢ Total Events: 8\\nâ€¢ Filtered Events: 8 (showing first 3)\\n\\nEvents:\\n1. system.ExtrinsicSuccess (Extrinsic 1)\\n   â””â”€ Extrinsic executed successfully\\n\\n2. balances.Transfer (Extrinsic 2)\\n   â””â”€ 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY â†’ 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty (10000000000 units)\\n\\n3. system.ExtrinsicSuccess (Extrinsic 2)\\n   â””â”€ Extrinsic executed successfully\\n\\nðŸ“‹ 5 more events available. Use a higher limit to see more.',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetReferendaContent extends Content {\n    limit?: number;\n}\n\nexport interface ReferendumInfo {\n    id: number;\n    trackId: number;\n    trackName: string;\n    status: string;\n    proposalHash?: string;\n    submitted?: string;\n    submissionDeposit?: {\n        who: string;\n        amount: string;\n    };\n    decisionDeposit?: {\n        who: string;\n        amount: string;\n    };\n    deciding?: {\n        since: string;\n        confirming?: string;\n    };\n    tally?: {\n        ayes: string;\n        nays: string;\n        support: string;\n    };\n    alarm?: string;\n}\n\n// Define proper types for API responses\ninterface ReferendumApiResponse {\n    isSome: boolean;\n    unwrap: () => {\n        toJSON: () => ReferendumData;\n    };\n}\n\ninterface ReferendumData {\n    ongoing?: OngoingReferendum;\n    approved?: unknown;\n    rejected?: unknown;\n    cancelled?: unknown;\n    timedOut?: unknown;\n    killed?: unknown;\n}\n\ninterface OngoingReferendum {\n    track: number;\n    proposal?: {\n        lookup?: { hash: string };\n        inline?: string;\n    };\n    submitted?: number;\n    submissionDeposit?: {\n        who: string;\n        amount?: number;\n    };\n    decisionDeposit?: {\n        who: string;\n        amount?: number;\n    };\n    deciding?: {\n        since?: number;\n        confirming?: number;\n    };\n    tally?: {\n        ayes?: number;\n        nays?: number;\n        support?: number;\n    };\n    alarm?: number;\n}\n\nexport const referendaSchema = z.object({\n    limit: z\n        .union([z.number(), z.string()])\n        .optional()\n        .nullable()\n        .transform((val) => {\n            if (val === 'null' || val === null || val === undefined) return undefined;\n            const num = typeof val === 'string' ? parseInt(val) : val;\n            return Number.isNaN(num) ? undefined : Math.min(Math.max(num, 1), 50);\n        }),\n});\n\nexport const referendaTemplate = `Respond with a JSON markdown block containing only the extracted values.\n  \n  Extract the number of referenda the user wants to see from their message.\n  Look for numbers like \"show me 5 referenda\", \"get 10 proposals\", \"last 3 governance items\", etc.\n  \n  If no specific number is mentioned, omit the limit field to use the default.\n  Maximum limit is 50.\n  \n  Example responses:\n  \\`\\`\\`json\n  {\n    \"limit\": 10\n  }\n  \\`\\`\\`\n  or\n  \\`\\`\\`json\n  {}\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\nexport async function buildGetReferendaDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<GetReferendaContent> {\n    const prompt = composePromptFromState({\n        state,\n        template: referendaTemplate,\n    });\n\n    const parsedResponse: GetReferendaContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as GetReferendaContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = referendaSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid number of referenda from the message');\n    }\n\n    return validatedResponse.data as GetReferendaContent;\n}\n\n// Helper function to get track name from track ID\nfunction getTrackName(trackId: number): string {\n    if (trackId === -1) {\n        return 'unknown';\n    }\n\n    const trackNames: { [key: number]: string } = {\n        0: 'root',\n        1: 'whitelisted_caller',\n        10: 'staking_admin',\n        11: 'treasurer',\n        12: 'lease_admin',\n        13: 'fellowship_admin',\n        14: 'general_admin',\n        15: 'auction_admin',\n        20: 'referendum_canceller',\n        21: 'referendum_killer',\n        30: 'small_tipper',\n        31: 'big_tipper',\n        32: 'small_spender',\n        33: 'medium_spender',\n        34: 'big_spender',\n    };\n\n    return trackNames[trackId] || `track_${trackId}`;\n}\n\n// Helper function to format referendum status\nfunction formatReferendumStatus(referendumInfo: ReferendumData): string {\n    if (referendumInfo.ongoing) {\n        return 'ongoing';\n    }\n    if (referendumInfo.approved) {\n        return 'approved';\n    }\n    if (referendumInfo.rejected) {\n        return 'rejected';\n    }\n    if (referendumInfo.cancelled) {\n        return 'cancelled';\n    }\n    if (referendumInfo.timedOut) {\n        return 'timedout';\n    }\n    if (referendumInfo.killed) {\n        return 'killed';\n    }\n    return 'unknown';\n}\n\n// Helper function to format large numbers\nfunction formatTokenAmount(amount: string, decimals = 10, symbol = 'DOT'): string {\n    const value = BigInt(amount);\n    const divisor = BigInt(10 ** decimals);\n    const quotient = value / divisor;\n    const remainder = value % divisor;\n\n    if (remainder === BigInt(0)) {\n        return `${quotient} ${symbol}`;\n    }\n    const decimal = remainder.toString().padStart(decimals, '0').replace(/0+$/, '');\n    return `${quotient}.${decimal} ${symbol}`;\n}\n\nexport class GetReferendaAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getReferenda(limit = 10): Promise<{\n        totalCount: number;\n        returnedCount: number;\n        referenda: ReferendumInfo[];\n    }> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n\n            // Get the total referendum count\n            const referendumCount = await api.query.referenda.referendumCount();\n            const totalCount = parseInt(referendumCount.toString());\n\n            const referenda: ReferendumInfo[] = [];\n            const maxLimit = Math.min(limit, 20); // Cap at 50\n\n            // Fetch referendum info for recent referenda (working backwards from latest)\n            for (let i = totalCount - 1; i >= 0 && referenda.length < maxLimit; i--) {\n                try {\n                    const referendumInfo = await api.query.referenda.referendumInfoFor(i);\n\n                    const apiResponse = referendumInfo as unknown as ReferendumApiResponse;\n                    if (apiResponse.isSome) {\n                        const info = apiResponse.unwrap().toJSON();\n\n                        // Extract track ID\n                        let trackId: number;\n                        if (\n                            info.ongoing &&\n                            typeof info.ongoing === 'object' &&\n                            info.ongoing.track !== undefined\n                        ) {\n                            trackId = info.ongoing.track;\n                        } else {\n                            // For completed referenda, track info is not preserved, in the future we could snapshot the api to get histroical\n                            trackId = -1; // Use -1 to indicate unknown track\n                        }\n\n                        const status = formatReferendumStatus(info);\n\n                        // Extract referendum data\n                        const referendum: ReferendumInfo = {\n                            id: i,\n                            trackId,\n                            trackName: getTrackName(trackId),\n                            status,\n                        };\n\n                        // Add additional details for ongoing referenda\n                        if (info.ongoing) {\n                            referendum.proposalHash =\n                                info.ongoing.proposal?.lookup?.hash ||\n                                info.ongoing.proposal?.inline ||\n                                'unknown';\n                            referendum.submitted = info.ongoing.submitted?.toString();\n\n                            if (info.ongoing.submissionDeposit) {\n                                referendum.submissionDeposit = {\n                                    who: info.ongoing.submissionDeposit.who,\n                                    amount:\n                                        info.ongoing.submissionDeposit.amount?.toString() || '0',\n                                };\n                            }\n\n                            if (info.ongoing.decisionDeposit) {\n                                referendum.decisionDeposit = {\n                                    who: info.ongoing.decisionDeposit.who,\n                                    amount: info.ongoing.decisionDeposit.amount?.toString() || '0',\n                                };\n                            }\n\n                            if (info.ongoing.deciding) {\n                                referendum.deciding = {\n                                    since: info.ongoing.deciding.since?.toString(),\n                                    confirming: info.ongoing.deciding.confirming?.toString(),\n                                };\n                            }\n\n                            if (info.ongoing.tally) {\n                                referendum.tally = {\n                                    ayes: info.ongoing.tally.ayes?.toString() || '0',\n                                    nays: info.ongoing.tally.nays?.toString() || '0',\n                                    support: info.ongoing.tally.support?.toString() || '0',\n                                };\n                            }\n\n                            if (info.ongoing.alarm) {\n                                referendum.alarm = info.ongoing.alarm.toString();\n                            }\n                        }\n\n                        referenda.push(referendum);\n                    }\n                } catch (error) {\n                    // Skip referenda that can't be fetched\n                    elizaLogger.debug(`Skipping referendum ${i}: ${(error as Error).message}`);\n                }\n            }\n\n            return {\n                totalCount,\n                returnedCount: referenda.length,\n                referenda,\n            };\n        } catch (error) {\n            elizaLogger.error('Error fetching referenda:', error);\n            throw new Error(`Failed to retrieve referenda: ${(error as Error).message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_REFERENDA',\n    similes: [\n        'VIEW_REFERENDA',\n        'POLKADOT_REFERENDA',\n        'GET_GOVERNANCE_REFERENDA',\n        'GOVERNANCE_PROPOSALS',\n        'VIEW_PROPOSALS',\n        'SHOW_REFERENDA',\n    ],\n    description:\n        \"Retrieves recent governance referenda from Polkadot's OpenGov system. Shows referendum details including track, status, voting results, and deposits.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_REFERENDA action...');\n\n        try {\n            const getReferendaContent = await buildGetReferendaDetails(runtime, message, state);\n\n            elizaLogger.debug('getReferendaContent', getReferendaContent);\n\n            const action = new GetReferendaAction(runtime);\n            const referendaInfo = await action.getReferenda(getReferendaContent.limit || 10);\n\n            // Format referenda for display\n            const referendaDisplay = referendaInfo.referenda\n                .map((ref, idx) => {\n                    let details = `${idx + 1}. Referendum ${ref.id} (${ref.trackName})\n   Status: ${ref.status.toUpperCase()}`;\n\n                    if (ref.tally) {\n                        const ayes = formatTokenAmount(ref.tally.ayes, 3);\n                        const nays = formatTokenAmount(ref.tally.nays, 3);\n                        details += `\n   Votes: ${ayes} AYE, ${nays} NAY`;\n                    }\n\n                    if (ref.deciding) {\n                        details += `\n   Deciding since block: ${ref.deciding.since}`;\n                        if (ref.deciding.confirming) {\n                            details += ` (confirming since: ${ref.deciding.confirming})`;\n                        }\n                    }\n\n                    if (ref.submissionDeposit) {\n                        const deposit = formatTokenAmount(ref.submissionDeposit.amount, 3);\n                        details += `\n   Deposit: ${deposit} by ${ref.submissionDeposit.who}`;\n                    }\n\n                    return details;\n                })\n                .join('\\n\\n');\n\n            const userMessageText = `\nðŸ›ï¸ Polkadot Governance Referenda\n\nSummary:\nâ€¢ Total Referenda: ${referendaInfo.totalCount}\nâ€¢ Showing: ${referendaInfo.returnedCount}\n\n${\n    referendaInfo.referenda.length > 0\n        ? `Recent Referenda:\\n${referendaDisplay}`\n        : 'âŒ No referenda found.'\n}\n\nðŸ’¡ Note: Completed referenda show \"unknown\" track as this information is not preserved on-chain.`;\n\n            const result = {\n                status: 'success',\n                totalCount: referendaInfo.totalCount,\n                returnedCount: referendaInfo.returnedCount,\n                referenda: referendaInfo.referenda,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving referenda:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving referenda: ${(error as Error).message}`,\n                    content: { error: (error as Error).message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'What are the current governance referenda?',\n                    action: 'GET_REFERENDA',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Here's a list of current ongoing referenda...\",\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Show me the last 5 governance proposals',\n                    action: 'GET_REFERENDA',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Here's a list of the 5 latest referenda...\",\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Get me 20 referenda',\n                    action: 'GET_REFERENDA',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"Here's a list of the last 20 referenda...\",\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { z } from 'zod';\nimport { PolkadotApiService } from '../services/api-service';\n\nexport interface GetReferendumDetailsContent extends Content {\n    referendumId: number;\n}\n\nexport interface DetailedReferendumInfo {\n    id: number;\n    trackId: number;\n    trackName: string;\n    status: string;\n    proposalHash?: string;\n    proposalLength?: number;\n    enactmentDelay?: number;\n    submitted?: string;\n    submissionDeposit?: {\n        who: string;\n        amount: string;\n        formattedAmount: string;\n    };\n    decisionDeposit?: {\n        who: string;\n        amount: string;\n        formattedAmount: string;\n    };\n    deciding?: {\n        since: string;\n        confirming?: string;\n    };\n    tally?: {\n        ayes: string;\n        nays: string;\n        support: string;\n        formattedAyes: string;\n        formattedNays: string;\n        formattedSupport: string;\n    };\n    inQueue?: boolean;\n    alarm?: string[];\n    completionBlock?: string;\n    origin?: string;\n}\n\ninterface ReferendumInfoData {\n    ongoing?: {\n        track: number;\n        proposal?: {\n            lookup?: {\n                hash: string;\n                len?: number;\n            };\n            inline?: string;\n        };\n        origin?: {\n            origins: string;\n        };\n        enactment?: {\n            after: number;\n        };\n        submitted?: string | number;\n        submissionDeposit?: {\n            who: string;\n            amount?: string | number;\n        };\n        decisionDeposit?: {\n            who: string;\n            amount?: string | number;\n        };\n        deciding?: {\n            since?: string | number;\n            confirming?: string | number;\n        };\n        tally?: {\n            ayes?: string | number;\n            nays?: string | number;\n            support?: string | number;\n        };\n        inQueue?: boolean;\n        alarm?: string | number | (string | number)[];\n    };\n    approved?: string[] | { since: string };\n    rejected?: string[];\n    cancelled?: string[];\n    timedOut?: string[];\n    killed?: string[];\n}\n\ninterface ReferendumApiResponse {\n    isSome: boolean;\n    unwrap: () => {\n        toJSON: () => ReferendumInfoData;\n    };\n}\n\nexport const referendumDetailsSchema = z.object({\n    referendumId: z.union([z.number(), z.string()]).transform((val) => {\n        const num = typeof val === 'string' ? parseInt(val) : val;\n        if (Number.isNaN(num) || num < 0) {\n            throw new Error('Invalid referendum ID');\n        }\n        return num;\n    }),\n});\n\nexport const referendumDetailsTemplate = `Respond with a JSON markdown block containing only the extracted referendum ID.\n  \n  Extract the referendum ID number from the user's message. Look for patterns like:\n  - \"referendum 123\"\n  - \"proposal 456\"\n  - \"ref 789\"\n  - \"referendum #42\"\n  - \"show me referendum 100\"\n  - \"details for 200\"\n  - just a plain number if the context is about referenda\n  \n  The referendum ID must be a valid positive number.\n  \n  Example responses:\n  \\`\\`\\`json\n  {\n    \"referendumId\": 123\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  Respond with a JSON markdown block containing only the referendum ID.`;\n\nexport async function buildGetReferendumDetailsRequest(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<GetReferendumDetailsContent> {\n    const prompt = composePromptFromState({\n        state,\n        template: referendumDetailsTemplate,\n    });\n\n    const parsedResponse: GetReferendumDetailsContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(\n            response,\n        ) as GetReferendumDetailsContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = referendumDetailsSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid referendum ID from the message');\n    }\n\n    return validatedResponse.data as GetReferendumDetailsContent;\n}\n\n// Helper function to get track name from track ID\nfunction getTrackName(trackId: number): string {\n    if (trackId === -1) {\n        return 'unknown';\n    }\n\n    const trackNames: { [key: number]: string } = {\n        0: 'root',\n        1: 'whitelisted_caller',\n        10: 'staking_admin',\n        11: 'treasurer',\n        12: 'lease_admin',\n        13: 'fellowship_admin',\n        14: 'general_admin',\n        15: 'auction_admin',\n        20: 'referendum_canceller',\n        21: 'referendum_killer',\n        30: 'small_tipper',\n        31: 'big_tipper',\n        32: 'small_spender',\n        33: 'medium_spender',\n        34: 'big_spender',\n    };\n\n    return trackNames[trackId] || `track_${trackId}`;\n}\n\n// Helper function to format referendum status\nfunction formatReferendumStatus(referendumInfo: ReferendumInfoData): string {\n    if (referendumInfo.ongoing) {\n        return 'ongoing';\n    }\n    if (referendumInfo.approved) {\n        return 'approved';\n    }\n    if (referendumInfo.rejected) {\n        return 'rejected';\n    }\n    if (referendumInfo.cancelled) {\n        return 'cancelled';\n    }\n    if (referendumInfo.timedOut) {\n        return 'timedout';\n    }\n    if (referendumInfo.killed) {\n        return 'killed';\n    }\n    return 'unknown';\n}\n\n// Helper function to format large numbers\nfunction formatTokenAmount(amount: string, decimals = 10, symbol = 'DOT'): string {\n    const value = BigInt(amount);\n    const divisor = BigInt(10 ** decimals);\n    const quotient = value / divisor;\n    const remainder = value % divisor;\n\n    if (remainder === BigInt(0)) {\n        return `${quotient} ${symbol}`;\n    }\n    const decimal = remainder.toString().padStart(decimals, '0').replace(/0+$/, '');\n    return `${quotient}.${decimal} ${symbol}`;\n}\n\nexport class GetReferendumDetailsAction {\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async getReferendumDetails(referendumId: number): Promise<DetailedReferendumInfo> {\n        try {\n            const apiService = await PolkadotApiService.start(this.runtime);\n            const api = await apiService.getConnection();\n\n            // Get the total referendum count to validate the ID\n            const referendumCount = await api.query.referenda.referendumCount();\n            const totalCount = parseInt(referendumCount.toString());\n\n            if (referendumId >= totalCount) {\n                throw new Error(\n                    `Referendum ${referendumId} does not exist. Latest referendum is ${\n                        totalCount - 1\n                    }.`,\n                );\n            }\n\n            // Fetch the specific referendum\n            const referendumInfo = await api.query.referenda.referendumInfoFor(referendumId);\n\n            const typedReferendumInfo = referendumInfo as unknown as ReferendumApiResponse;\n\n            if (!typedReferendumInfo.isSome) {\n                throw new Error(`Referendum ${referendumId} not found or has no data.`);\n            }\n\n            const info = typedReferendumInfo.unwrap().toJSON();\n            elizaLogger.info(info);\n\n            // Extract track ID\n            let trackId: number;\n            if (\n                info.ongoing &&\n                typeof info.ongoing === 'object' &&\n                info.ongoing.track !== undefined\n            ) {\n                trackId = info.ongoing.track;\n            } else {\n                // For completed referenda, track info is not preserved\n                trackId = -1;\n            }\n\n            const status = formatReferendumStatus(info);\n\n            // Build detailed referendum info\n            const referendum: DetailedReferendumInfo = {\n                id: referendumId,\n                trackId,\n                trackName: getTrackName(trackId),\n                status,\n            };\n\n            // Extract common details for ongoing referenda\n            if (info.ongoing) {\n                // Proposal information\n                referendum.proposalHash =\n                    info.ongoing.proposal?.lookup?.hash ||\n                    info.ongoing.proposal?.inline ||\n                    'unknown';\n                referendum.proposalLength = info.ongoing.proposal?.lookup?.len;\n\n                // Origin information\n                referendum.origin = info.ongoing.origin?.origins || 'unknown';\n\n                // Enactment delay\n                referendum.enactmentDelay = info.ongoing.enactment?.after;\n\n                // Submission details\n                referendum.submitted = info.ongoing.submitted?.toString();\n\n                // Deposits\n                if (info.ongoing.submissionDeposit) {\n                    referendum.submissionDeposit = {\n                        who: info.ongoing.submissionDeposit.who,\n                        amount: info.ongoing.submissionDeposit.amount?.toString() || '0',\n                        formattedAmount: formatTokenAmount(\n                            info.ongoing.submissionDeposit.amount?.toString() || '0',\n                        ),\n                    };\n                }\n\n                if (info.ongoing.decisionDeposit) {\n                    referendum.decisionDeposit = {\n                        who: info.ongoing.decisionDeposit.who,\n                        amount: info.ongoing.decisionDeposit.amount?.toString() || '0',\n                        formattedAmount: formatTokenAmount(\n                            info.ongoing.decisionDeposit.amount?.toString() || '0',\n                        ),\n                    };\n                }\n\n                // Deciding phase\n                if (info.ongoing.deciding) {\n                    referendum.deciding = {\n                        since: info.ongoing.deciding.since?.toString(),\n                        confirming: info.ongoing.deciding.confirming?.toString(),\n                    };\n                }\n\n                // Tally\n                if (info.ongoing.tally) {\n                    referendum.tally = {\n                        ayes: info.ongoing.tally.ayes?.toString() || '0',\n                        nays: info.ongoing.tally.nays?.toString() || '0',\n                        support: info.ongoing.tally.support?.toString() || '0',\n                        formattedAyes: formatTokenAmount(\n                            info.ongoing.tally.ayes?.toString() || '0',\n                        ),\n                        formattedNays: formatTokenAmount(\n                            info.ongoing.tally.nays?.toString() || '0',\n                        ),\n                        formattedSupport: formatTokenAmount(\n                            info.ongoing.tally.support?.toString() || '0',\n                        ),\n                    };\n                }\n\n                // Queue status\n                referendum.inQueue = info.ongoing.inQueue || false;\n\n                // Alarm\n                if (info.ongoing.alarm) {\n                    referendum.alarm = Array.isArray(info.ongoing.alarm)\n                        ? info.ongoing.alarm.map((a) => a.toString())\n                        : [info.ongoing.alarm.toString()];\n                }\n            } else {\n                // For completed referenda, extract completion block if available\n                if (info.approved && Array.isArray(info.approved) && info.approved[0]) {\n                    referendum.completionBlock = info.approved[0].toString();\n                } else if (info.rejected && Array.isArray(info.rejected) && info.rejected[0]) {\n                    referendum.completionBlock = info.rejected[0].toString();\n                } else if (info.cancelled && Array.isArray(info.cancelled) && info.cancelled[0]) {\n                    referendum.completionBlock = info.cancelled[0].toString();\n                } else if (info.timedOut && Array.isArray(info.timedOut) && info.timedOut[0]) {\n                    referendum.completionBlock = info.timedOut[0].toString();\n                } else if (info.killed && Array.isArray(info.killed) && info.killed[0]) {\n                    referendum.completionBlock = info.killed[0].toString();\n                }\n            }\n\n            return referendum;\n        } catch (error) {\n            elizaLogger.error(`Error fetching referendum ${referendumId}:`, error);\n            throw new Error(`Failed to retrieve referendum ${referendumId}: ${error.message}`);\n        }\n    }\n}\n\nexport default {\n    name: 'GET_REFERENDUM_DETAILS',\n    similes: [\n        'VIEW_REFERENDUM_DETAILS',\n        'REFERENDUM_INFO',\n        'GET_REFERENDUM_INFO',\n        'SHOW_REFERENDUM',\n        'REFERENDUM_DETAILS',\n        'PROPOSAL_DETAILS',\n    ],\n    description:\n        \"Retrieves detailed information about a specific governance referendum from Polkadot's OpenGov system by referendum ID.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting GET_REFERENDUM_DETAILS action...');\n\n        try {\n            const detailsContent = await buildGetReferendumDetailsRequest(runtime, message, state);\n\n            elizaLogger.debug('detailsContent', detailsContent);\n\n            const action = new GetReferendumDetailsAction(runtime);\n            const referendum = await action.getReferendumDetails(detailsContent.referendumId);\n\n            // Format details for display\n            let userMessageText = `\nðŸ›ï¸ Referendum ${referendum.id} Details\n\nOverview:\nâ€¢ Track: ${referendum.trackName} (${\n                referendum.trackId === -1 ? 'track info not preserved' : `ID: ${referendum.trackId}`\n            })\nâ€¢ Status: ${referendum.status.toUpperCase()}`;\n\n            if (referendum.origin) {\n                userMessageText += `\nâ€¢ Origin: ${referendum.origin}`;\n            }\n\n            if (referendum.completionBlock) {\n                userMessageText += `\nâ€¢ Completed at block: ${referendum.completionBlock}`;\n            }\n\n            if (referendum.proposalHash) {\n                userMessageText += `\n\nProposal:\nâ€¢ Hash: ${referendum.proposalHash}`;\n\n                if (referendum.proposalLength) {\n                    userMessageText += `\nâ€¢ Length: ${referendum.proposalLength} bytes`;\n                }\n\n                if (referendum.enactmentDelay) {\n                    userMessageText += `\nâ€¢ Enactment delay: ${referendum.enactmentDelay} blocks`;\n                }\n            }\n\n            if (referendum.submitted) {\n                userMessageText += `\n\nTimeline:\nâ€¢ Submitted at block: ${referendum.submitted}`;\n\n                if (referendum.deciding) {\n                    userMessageText += `\nâ€¢ Deciding since block: ${referendum.deciding.since}`;\n                    if (referendum.deciding.confirming) {\n                        userMessageText += `\nâ€¢ Confirming since block: ${referendum.deciding.confirming}`;\n                    }\n                }\n            }\n\n            if (referendum.tally) {\n                const ayesPercent =\n                    referendum.tally.ayes !== '0' && referendum.tally.nays !== '0'\n                        ? (\n                              (BigInt(referendum.tally.ayes) * BigInt(100)) /\n                              (BigInt(referendum.tally.ayes) + BigInt(referendum.tally.nays))\n                          ).toString()\n                        : 'N/A';\n\n                userMessageText += `\n\nðŸ—³ï¸ Voting Results:\nâ€¢ Ayes: ${referendum.tally.formattedAyes}`;\n\n                if (ayesPercent !== 'N/A') {\n                    userMessageText += ` (${ayesPercent}%)`;\n                }\n\n                userMessageText += `\nâ€¢ Nays: ${referendum.tally.formattedNays}\nâ€¢ Support: ${referendum.tally.formattedSupport}`;\n            }\n\n            if (referendum.submissionDeposit || referendum.decisionDeposit) {\n                userMessageText += `\n\nDeposits:`;\n\n                if (referendum.submissionDeposit) {\n                    userMessageText += `\nâ€¢ Submission: ${referendum.submissionDeposit.formattedAmount} by ${referendum.submissionDeposit.who}`;\n                }\n\n                if (referendum.decisionDeposit) {\n                    userMessageText += `\nâ€¢ Decision: ${referendum.decisionDeposit.formattedAmount} by ${referendum.decisionDeposit.who}`;\n                }\n            }\n\n            if (referendum.alarm) {\n                userMessageText += `\n\nâ° Alarm: Set for block ${referendum.alarm[0]}`;\n            }\n\n            if (referendum.inQueue !== undefined) {\n                userMessageText += `\n\nQueue Status: ${referendum.inQueue ? 'In queue' : 'Not in queue'}`;\n            }\n\n            const result = {\n                status: 'success',\n                referendum,\n            };\n\n            if (callback) {\n                callback({\n                    text: userMessageText,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error retrieving referendum details:', error);\n            if (callback) {\n                callback({\n                    text: `Error retrieving referendum details: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Show me details for referendum 586',\n                    action: 'GET_REFERENDUM_DETAILS',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ›ï¸ Referendum 586 Details\\n\\nOverview:\\nâ€¢ Track: medium_spender (ID: 33)\\nâ€¢ Status: ONGOING\\nâ€¢ Origin: MediumSpender\\n\\nProposal:\\nâ€¢ Hash: 0xad649d315fe4c18ce3f9b9c09c698c0c860508cb3bcccdbce5adede355a26850\\nâ€¢ Length: 60 bytes\\nâ€¢ Enactment delay: 100 blocks\\n\\nTimeline:\\nâ€¢ Submitted at block: 26316166\\nâ€¢ Deciding since block: 26318566\\n\\nðŸ—³ï¸ Voting Results:\\nâ€¢ Ayes: 105.0 DOT (100%)\\nâ€¢ Nays: 0 DOT\\nâ€¢ Support: 35.0 DOT\\n\\nDeposits:\\nâ€¢ Submission: 1.0 DOT by 136byv85...n5Rz\\nâ€¢ Decision: 200.0 DOT by 136byv85...n5Rz\\n\\nâ° Alarm: Set for block 26721700\\n\\nQueue Status: Not in queue',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Get referendum 500 info',\n                    action: 'GET_REFERENDUM_DETAILS',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ›ï¸ Referendum 500 Details\\n\\nOverview:\\nâ€¢ Track: unknown (track info not preserved)\\nâ€¢ Status: APPROVED\\nâ€¢ Completed at block: 24567890\\n\\nðŸ’¡ Note: This referendum has been completed. Detailed voting information and track data are not preserved on-chain for completed referenda.',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: \"What's the status of proposal 123?\",\n                    action: 'GET_REFERENDUM_DETAILS',\n                },\n            },\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'ðŸ›ï¸ Referendum 123 Details\\n\\nOverview:\\nâ€¢ Track: treasurer (ID: 11)\\nâ€¢ Status: ONGOING\\nâ€¢ Origin: Treasurer\\n\\nProposal:\\nâ€¢ Hash: 0x1234567890abcdef1234567890abcdef12345678\\nâ€¢ Length: 45 bytes\\nâ€¢ Enactment delay: 50 blocks\\n\\nTimeline:\\nâ€¢ Submitted at block: 26200000\\nâ€¢ Deciding since block: 26202000\\n\\nðŸ—³ï¸ Voting Results:\\nâ€¢ Ayes: 5,432.1 DOT (92%)\\nâ€¢ Nays: 456.7 DOT\\nâ€¢ Support: 1,234.5 DOT\\n\\nDeposits:\\nâ€¢ Submission: 10.0 DOT by 5GrwvaEF...Xb26\\nâ€¢ Decision: 100.0 DOT by 5GrwvaEF...Xb26\\n\\nQueue Status: Not in queue',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, Provider, ProviderResult, State } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\nimport { PolkadotApiService } from '../services/api-service';\n\ninterface ChainInfo {\n    name: string;\n    nodeName: string;\n    nodeVersion: string;\n    properties: {\n        tokenSymbol: string;\n        tokenDecimals: number;\n    };\n    health: {\n        peers: number;\n        isSyncing: boolean;\n        shouldHavePeers: boolean;\n    };\n    blocks: {\n        best: string;\n        finalized: string;\n    };\n    timestamp: number;\n}\n\n// Define types for API responses to avoid using any\ninterface PolkadotChainProperties {\n    tokenSymbol: {\n        unwrap: () => Array<{ toString: () => string }>;\n    };\n    tokenDecimals: {\n        unwrap: () => Array<{ toNumber: () => number }>;\n    };\n}\n\ninterface PolkadotHealth {\n    peers: { toNumber: () => number };\n    isSyncing: { valueOf: () => boolean };\n    shouldHavePeers: { valueOf: () => boolean };\n}\n\ninterface PolkadotCodec {\n    toString: () => string;\n    toJSON: () => unknown[];\n    toNumber?: () => number;\n}\n\nclass ChainDataService {\n    private apiService: PolkadotApiService;\n\n    public async initialize(runtime: IAgentRuntime): Promise<void> {\n        this.apiService = await PolkadotApiService.start(runtime);\n    }\n\n    public async getChainInfo(): Promise<ChainInfo> {\n        const api = await this.apiService.getConnection();\n\n        const [chain, nodeName, nodeVersion, properties, health, bestNumber, finalizedNumber] =\n            await Promise.all([\n                api.rpc.system.chain(),\n                api.rpc.system.name(),\n                api.rpc.system.version(),\n                api.rpc.system.properties(),\n                api.rpc.system.health(),\n                api.derive.chain.bestNumber(),\n                api.derive.chain.bestNumberFinalized(),\n            ]);\n\n        // Type the properties response properly\n        const typedProperties = properties as unknown as PolkadotChainProperties;\n        const typedHealth = health as unknown as PolkadotHealth;\n\n        const chainInfo: ChainInfo = {\n            name: chain.toString(),\n            nodeName: nodeName.toString(),\n            nodeVersion: nodeVersion.toString(),\n            properties: {\n                tokenSymbol: typedProperties.tokenSymbol.unwrap()[0].toString(),\n                tokenDecimals: typedProperties.tokenDecimals.unwrap()[0].toNumber(),\n            },\n            health: {\n                peers: typedHealth.peers.toNumber(),\n                isSyncing: typedHealth.isSyncing.valueOf(),\n                shouldHavePeers: typedHealth.shouldHavePeers.valueOf(),\n            },\n            blocks: {\n                best: bestNumber.toString(),\n                finalized: finalizedNumber.toString(),\n            },\n            timestamp: Date.now(),\n        };\n\n        return chainInfo;\n    }\n\n    public async getValidatorCount(): Promise<number> {\n        const api = await this.apiService.getConnection();\n        let count = 0;\n\n        try {\n            // Convert validators to array first\n            const validators = await api.query.session.validators();\n            const validatorsCodec = validators as unknown as PolkadotCodec;\n            const validatorsArray = validatorsCodec.toJSON() as unknown[];\n            count = Array.isArray(validatorsArray) ? validatorsArray.length : 0;\n        } catch (_error) {\n            try {\n                // Convert validator count to number\n                const validatorCount = await api.query.staking.validatorCount();\n                // Use toString and parseInt to avoid toNumber type errors\n                count = parseInt(validatorCount.toString());\n            } catch (innerError) {\n                const message =\n                    innerError instanceof Error ? innerError.message : String(innerError);\n                elizaLogger.error(`Error fetching validator count: ${message}`);\n            }\n        }\n\n        return count;\n    }\n\n    public async getParachainCount(): Promise<number> {\n        const api = await this.apiService.getConnection();\n        let count = 0;\n\n        try {\n            if (api.query.paras?.parachains) {\n                const parachains = await api.query.paras.parachains();\n                // Convert to array first with proper typing\n                const parachainsCodec = parachains as unknown as PolkadotCodec;\n                const parachainsArray = parachainsCodec.toJSON() as unknown[];\n                count = Array.isArray(parachainsArray) ? parachainsArray.length : 0;\n            }\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`Error fetching parachain count: ${message}`);\n        }\n\n        return count;\n    }\n\n    public formatChainInfo(chainInfo: ChainInfo): string {\n        const timeSinceUpdate = Math.floor((Date.now() - chainInfo.timestamp) / 1000);\n\n        return `Polkadot Network Status (updated ${timeSinceUpdate}s ago):\n- Network: ${chainInfo.name}\n- Connected: ${chainInfo.health.peers > 0 ? 'Yes' : 'No'} (${chainInfo.health.peers} peers)\n- Synced: ${!chainInfo.health.isSyncing ? 'Yes' : 'No'}\n- Latest Block: #${chainInfo.blocks.best} (finalized: #${chainInfo.blocks.finalized})\n- Native Token: ${chainInfo.properties.tokenSymbol}`;\n    }\n}\n\nexport const networkDataProvider: Provider = {\n    name: 'NETWORK_DATA_PROVIDER',\n    async get(_runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<ProviderResult> {\n        try {\n            const chainDataService = new ChainDataService();\n            await chainDataService.initialize(_runtime);\n\n            const chainInfo = await chainDataService.getChainInfo();\n\n            const [validatorCount, parachainCount] = await Promise.all([\n                chainDataService.getValidatorCount(),\n                chainDataService.getParachainCount(),\n            ]);\n\n            let output = chainDataService.formatChainInfo(chainInfo);\n\n            if (validatorCount > 0) {\n                output += `\\n- Active Validators: ${validatorCount}`;\n            }\n\n            if (parachainCount > 0) {\n                output += `\\n- Connected Parachains: ${parachainCount}`;\n            }\n\n            elizaLogger.info('Network Data Provider output generated', output);\n            return {\n                text: output,\n                data: {\n                    networkInfo: chainInfo,\n                },\n            };\n        } catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            elizaLogger.error(`Error in Network Data Provider: ${message}`);\n\n            return {\n                text: 'Network Data Provider: Unable to retrieve current network status.',\n                data: {\n                    error: message,\n                },\n            };\n        }\n    },\n};\n\nexport default networkDataProvider;\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport { z } from 'zod';\nimport { PolkadotApiService } from 'src/services/api-service';\n\nexport interface TransferFundsContent extends Content {\n    recipientAddress: string;\n    amount: string;\n    walletNumber?: number;\n    walletAddress?: string;\n    password?: string;\n}\n\n// Define a schema for input JSON\nexport const transferFundsSchema = z.object({\n    recipientAddress: z.string(),\n    amount: z.string(),\n    walletNumber: z.number().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    password: z.string().optional().nullable(),\n});\n\n// Define a template to guide object building\nexport const transferFundsTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n  Example response:\n  \\`\\`\\`json\n  {\n    \"recipientAddress\": \"<recipient address>\",\n    \"amount\": \"<numeric amount only, without asset symbol>\",\n    \"walletNumber\": <optional wallet number>,\n    \"walletAddress\": \"<optional wallet address>\",\n    \"password\": \"<optional password>\"\n  }\n  \\`\\`\\`\n  \n  {{recentMessages}}\n\n  If a wallet number or address is not provided in the latest message, return null for those values.\n  If a password is not provided in the latest message, return null for the password.\n\n  IMPORTANT: For the \"amount\" field, extract ONLY the numeric value without any asset symbols or currency names. \n  For example, if the user says \"transfer 1000 PAS\", the amount should be \"1000\", not \"1000 PAS\".\n\n  Respond with a JSON markdown block containing only the extracted values.`;\n\n/**\n * Builds and validates a transfer funds object using the provided runtime, message, and state.\n */\nexport async function buildTransferFundsDetails(\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n): Promise<TransferFundsContent> {\n    // Compose the current state (or create one based on the message)\n    const currentState = state || (await runtime.composeState(message));\n\n    // Compose a context to drive the object generation\n    const prompt = composePromptFromState({\n        state: currentState,\n        template: transferFundsTemplate,\n    });\n\n    // Generate an object using the defined schema\n    const parsedResponse: TransferFundsContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(response) as TransferFundsContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    //zod validate the response\n    const validatedResponse = transferFundsSchema.safeParse(parsedResponse);\n\n    if (!validatedResponse.success) {\n        throw new Error('Failed to extract a valid transfer funds details from the message');\n    }\n\n    return validatedResponse.data as TransferFundsContent;\n}\n\nexport class TransferFundsAction {\n    private runtime: IAgentRuntime;\n    private walletProvider: WalletProvider;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async initialize(): Promise<void> {\n        this.walletProvider = await initWalletProvider(this.runtime);\n    }\n\n    async transferFunds(params: {\n        recipientAddress: string;\n        amount: string;\n        walletNumber?: number;\n        walletAddress?: string;\n        password?: string;\n        dryRun?: boolean;\n    }): Promise<{\n        status: string;\n        txHash: string;\n        message: string;\n    }> {\n        // Load the appropriate wallet\n        let targetWallet: WalletProvider;\n        if (params.walletNumber) {\n            targetWallet = await WalletProvider.loadWalletByNumber(\n                this.walletProvider,\n                params.walletNumber,\n                params.password,\n            );\n        } else if (params.walletAddress) {\n            targetWallet = await WalletProvider.loadWalletByAddress(\n                this.walletProvider,\n                params.walletAddress,\n                params.password,\n            );\n        } else {\n            targetWallet = this.walletProvider;\n        }\n\n        // Get the keypair from the wallet\n        const keypair = targetWallet.keyring.getPairs()[0];\n        if (!keypair) {\n            throw new Error('No keypair found in the wallet');\n        }\n\n        const apiService = await PolkadotApiService.start(this.runtime);\n        const api = await apiService.getConnection();\n        elizaLogger.debug('API connection established');\n\n        const properties = await api.rpc.system.properties();\n\n        const tokenDecimals = properties.tokenDecimals.unwrap()[0].toNumber();\n\n        // Convert amount to the smallest unit (planck)\n        const amount = BigInt(params.amount) * BigInt(10 ** tokenDecimals);\n\n        // Create the transfer extrinsic\n        const transfer = api.tx.balances.transferAllowDeath(params.recipientAddress, amount);\n\n        if (params.dryRun) {\n            // Simulate the transfer without actually sending it\n            elizaLogger.debug(\n                `DRY RUN: Transfer of ${params.amount} DOT to ${params.recipientAddress} would be initiated.`,\n            );\n\n            return {\n                status: 'success',\n                txHash: '0xDRY_RUN_SIMULATION',\n                message: `DRY RUN: Transfer of ${params.amount} DOT to ${params.recipientAddress} would be initiated.`,\n            };\n        }\n\n        // Sign and send the transaction\n        const hash = await transfer.signAndSend(keypair);\n\n        elizaLogger.debug(\n            `Transfer of ${params.amount} DOT to ${\n                params.recipientAddress\n            } initiated. Transaction hash: ${hash.toHex()}`,\n        );\n\n        return {\n            status: 'success',\n            txHash: hash.toHex(),\n            message: `Transfer of ${params.amount} DOT to ${\n                params.recipientAddress\n            } initiated. Transaction hash: ${hash.toHex()}`,\n        };\n    }\n}\n\nexport default {\n    name: 'POLKADOT_TRANSFER',\n    similes: [\n        'SEND_POLKADOT_FUNDS',\n        'SEND',\n        'TRANSFER_POLKADOT_FUNDS',\n        'SEND_DOT',\n        'TRANSFER',\n        'NATIVE_TRANSFER',\n    ],\n    description: 'Transfers native tokens to another address.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting POLKADOT_TRANSFER action...');\n\n        // Build transfer details using the object building approach\n        const transferFundsContent = await buildTransferFundsDetails(runtime, message, state);\n\n        elizaLogger.debug('transferFundsContent', transferFundsContent);\n\n        if (\n            !transferFundsContent ||\n            !transferFundsContent.recipientAddress ||\n            !transferFundsContent.amount\n        ) {\n            elizaLogger.error('Failed to obtain required transfer details.');\n            if (callback) {\n                callback({\n                    text: 'Unable to process transfer request. Could not obtain recipient address or amount.',\n                    content: {\n                        error: 'Invalid transfer request. Required details could not be determined.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            // Initialize the transfer action\n            const action = new TransferFundsAction(runtime);\n            await action.initialize();\n\n            // Execute the transfer\n            const result = await action.transferFunds({\n                recipientAddress: transferFundsContent.recipientAddress,\n                amount: transferFundsContent.amount,\n                walletNumber: transferFundsContent.walletNumber,\n                walletAddress: transferFundsContent.walletAddress,\n                password: transferFundsContent.password,\n            });\n\n            if (callback) {\n                callback({\n                    text: result.message,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error transferring funds:', error);\n            if (callback) {\n                callback({\n                    text: `Error transferring funds: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please transfer 1 DOT to 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n                    action: 'POLKADOT_TRANSFER',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Transfer of 1 DOT to 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty initiated. Transaction hash: 0x...',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Send 0.5 DOT to 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty from wallet #2',\n                    action: 'POLKADOT_TRANSFER',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Transfer of 0.5 DOT to 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty from wallet #2 initiated. Transaction hash: 0x...',\n                },\n            },\n        ],\n    ],\n};\n","import type { IAgentRuntime, Memory, State, HandlerCallback, Content } from '@elizaos/core';\nimport {\n    elizaLogger,\n    ModelType,\n    composePromptFromState,\n    parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { WalletProvider, initWalletProvider } from '../providers/wallet';\nimport type { ApiPromise } from '@polkadot/api';\nimport { AssetTransferApi, constructApiPromise } from '@substrate/asset-transfer-api';\nimport type { TxResult } from '@substrate/asset-transfer-api';\nimport { CHAIN_RPC_MAPPING } from '../utils/chainRegistryUtils';\n\nimport { z } from 'zod';\n\nexport interface CrossChainTransferContent extends Content {\n    recipientAddress: string;\n    amount: string;\n    sourceChain: string;\n    destinationChain: string;\n    destinationParachainId: string;\n    assetId?: string;\n    walletNumber?: number;\n    walletAddress?: string;\n    password?: string;\n}\n\n// Define a schema for input JSON\nexport const crossChainTransferSchema = z.object({\n    recipientAddress: z.string(),\n    amount: z.string(),\n    sourceChain: z.string(),\n    destinationChain: z.string(),\n    destinationParachainId: z.string(),\n    assetId: z.string(),\n    walletNumber: z.number().optional().nullable(),\n    walletAddress: z.string().optional().nullable(),\n    password: z.string().optional().nullable(),\n});\n\n// Define a template to guide object building\nexport const crossChainTransferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n    Example response:\n    \\`\\`\\`json\n    {\n      \"recipientAddress\": \"<recipient address>\",\n      \"amount\": \"<numeric amount only, without asset symbol>\",\n      \"sourceChain\": \"<source chain name>\",\n      \"destinationChain\": \"<destination chain name>\",\n      \"destinationParachainId\": \"<destination parachain id>\",\n      \"assetId\": \"<asset symbol>\",\n      \"walletNumber\": <optional wallet number>,\n      \"walletAddress\": \"<optional wallet address>\",\n      \"password\": \"<optional password>\"\n    }\n    \\`\\`\\`\n    \n    {{recentMessages}}\n  \n    If a wallet number or address is not provided in the latest message, return null for those values.\n    If a password is not provided in the latest message, return null for the password.\n    If source chain is not provided, it will default to \"polkadot\".\n  \n    IMPORTANT: For the \"amount\" field, extract ONLY the numeric value without any asset symbols or currency names. \n    For example, if the user says \"transfer 1000 PAS\", the amount should be \"1000\", not \"1000 PAS\".\n  \n    Respond with a JSON markdown block containing only the extracted values.`;\n\n/**\n * Builds and validates a cross-chain transfer object using the provided runtime, message, and state.\n */\nexport async function buildCrossChainTransferDetails(\n    runtime: IAgentRuntime,\n    _message: Memory,\n    state: State,\n): Promise<CrossChainTransferContent> {\n    const prompt = composePromptFromState({\n        state,\n        template: crossChainTransferTemplate,\n    });\n\n    const parsedResponse: CrossChainTransferContent | null = null;\n    for (let i = 0; i < 5; i++) {\n        const response = await runtime.useModel(ModelType.TEXT_SMALL, {\n            prompt,\n        });\n        const parsedResponse = parseJSONObjectFromText(\n            response,\n        ) as CrossChainTransferContent | null;\n        if (parsedResponse) {\n            break;\n        }\n    }\n\n    return parsedResponse;\n}\n\nexport class CrossChainTransferAction {\n    private runtime: IAgentRuntime;\n    private walletProvider: WalletProvider;\n    private api: ApiPromise;\n    private assetApi: AssetTransferApi; // Using any temporarily to avoid type conflicts\n    private currentRpcUrl: string;\n    private sourceChainName: string;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async initialize(sourceChain: string): Promise<void> {\n        this.sourceChainName = sourceChain;\n        this.walletProvider = await initWalletProvider(this.runtime);\n\n        // Get the RPC URL from the mapping or use default\n        const chainName = sourceChain.toLowerCase();\n        this.currentRpcUrl = CHAIN_RPC_MAPPING[chainName];\n\n        if (!this.currentRpcUrl) {\n            throw new Error(`RPC URL not found for chain: ${sourceChain}`);\n        }\n\n        const { api, specName, safeXcmVersion } = await constructApiPromise(this.currentRpcUrl);\n        this.api = api;\n\n        // Initialize the Asset Transfer API\n        this.assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n    }\n\n    async transferFunds(\n        params: {\n            recipientAddress: string;\n            amount: string;\n            destinationChain: string;\n            destinationParachainId: string;\n            assetId?: string;\n            walletNumber?: number;\n            walletAddress?: string;\n            password?: string;\n        },\n        dryRun = false,\n    ): Promise<{\n        status: string;\n        message: string;\n        decodedTx?: string;\n        txHash?: string;\n    }> {\n        let targetWallet: WalletProvider;\n        if (params.walletNumber) {\n            targetWallet = await WalletProvider.loadWalletByNumber(\n                this.walletProvider,\n                params.walletNumber,\n                params.password,\n            );\n        } else if (params.walletAddress) {\n            targetWallet = await WalletProvider.loadWalletByAddress(\n                this.walletProvider,\n                params.walletAddress,\n                params.password,\n            );\n        } else {\n            targetWallet = this.walletProvider;\n        }\n\n        const keypair = targetWallet.keyring.getPairs()[0];\n        if (!keypair) {\n            throw new Error('No keypair found in the wallet');\n        }\n\n        const callInfo: TxResult<'call'> = await this.assetApi.createTransferTransaction(\n            params.destinationParachainId,\n            params.recipientAddress,\n            params.assetId ? [params.assetId] : [],\n            [params.amount],\n            {\n                format: 'call',\n                xcmVersion: this.assetApi.safeXcmVersion,\n            },\n        );\n\n        elizaLogger.debug('Transfer transaction created:', {\n            callInfoTx: callInfo.tx,\n        });\n\n        elizaLogger.log('Attempting to dry run the transaction...');\n        const dryRunResult = await this.assetApi.dryRunCall(\n            keypair.address,\n            callInfo.tx,\n            'call',\n            this.assetApi.safeXcmVersion,\n        );\n\n        if (dryRunResult === null) {\n            elizaLogger.warn('Dry run did not return a result. Proceeding with caution.');\n        } else if (dryRunResult.isErr) {\n            elizaLogger.error('Transaction dry run failed:', dryRunResult.asErr.toHuman());\n            throw new Error(`Transaction dry run failed: ${dryRunResult.asErr.toString()}`);\n        } else {\n            elizaLogger.log('Transaction dry run successful:', dryRunResult.asOk.toHuman());\n        }\n\n        let decodedTxString: string | undefined = undefined;\n        try {\n            decodedTxString = this.assetApi.decodeExtrinsic(callInfo.tx, 'call');\n            elizaLogger.debug('Decoded transaction:', JSON.parse(decodedTxString));\n        } catch (decodeError) {\n            elizaLogger.warn('Failed to decode transaction:', decodeError);\n        }\n\n        if (dryRun) {\n            return {\n                status: 'success',\n                message: `Dry run of cross-chain transfer of ${params.amount} ${params.assetId} from ${this.sourceChainName} to ${params.recipientAddress} on ${params.destinationChain} initiated.`,\n            };\n        }\n\n        const submitableTransaction: TxResult<'submittable'> =\n            await this.assetApi.createTransferTransaction(\n                params.destinationParachainId,\n                params.recipientAddress,\n                params.assetId ? [params.assetId] : [],\n                [params.amount],\n                {\n                    format: 'submittable',\n                    xcmVersion: this.assetApi.safeXcmVersion,\n                },\n            );\n\n        elizaLogger.log('Signing and sending the transaction...');\n        let hash: string | undefined = undefined;\n        const unsub = await submitableTransaction.tx.signAndSend(keypair, (result) => {\n            console.log(`Current status is ${result.status}`);\n\n            if (result.status.isInBlock) {\n                console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\n            } else if (result.status.isFinalized) {\n                console.log(`Transaction included at blockHash ${result.status.asFinalized}`);\n                hash = result.txHash.toHex();\n\n                unsub();\n            }\n        });\n\n        return {\n            status: 'success',\n            txHash: hash,\n            message: `Cross-chain transfer of ${params.amount} ${params.assetId} from ${this.sourceChainName} to ${params.recipientAddress} on ${params.destinationChain} initiated.`,\n            decodedTx: decodedTxString,\n        };\n    }\n}\n\nexport default {\n    name: 'CROSS_CHAIN_TRANSFER',\n    similes: ['CROSS_CHAIN_SEND', 'XCM_TRANSFER'],\n    description:\n        'Transfers tokens across different chains in the Polkadot ecosystem using XCM. Supports transfers between relay chains and parachains.',\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) => {\n        elizaLogger.log('Starting CROSS_CHAIN_TRANSFER action...');\n\n        // Build transfer details using the object building approach\n        const transferContent = await buildCrossChainTransferDetails(runtime, message, state);\n\n        elizaLogger.debug('crossChainTransferContent', transferContent);\n\n        if (\n            !transferContent ||\n            !transferContent.recipientAddress ||\n            !transferContent.amount ||\n            !transferContent.destinationChain\n        ) {\n            elizaLogger.error('Failed to obtain required transfer details.');\n            if (callback) {\n                callback({\n                    text: 'Unable to process cross-chain transfer request. Could not obtain required details.',\n                    content: {\n                        error: 'Invalid transfer request. Required details could not be determined.',\n                    },\n                });\n            }\n            return false;\n        }\n\n        try {\n            // Initialize the transfer action\n            const action = new CrossChainTransferAction(runtime);\n            await action.initialize(transferContent.sourceChain);\n\n            // Execute the transfer\n            const result = await action.transferFunds({\n                recipientAddress: transferContent.recipientAddress,\n                amount: transferContent.amount,\n                destinationChain: transferContent.destinationChain,\n                destinationParachainId: transferContent.destinationParachainId,\n                assetId: transferContent.assetId,\n                walletNumber: transferContent.walletNumber,\n                walletAddress: transferContent.walletAddress,\n                password: transferContent.password,\n            });\n\n            if (callback) {\n                callback({\n                    text: result.message,\n                    content: {\n                        status: result.status,\n                        message: result.message,\n                        decodedTx: result.decodedTx,\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error('Error in cross-chain transfer:', error);\n            if (callback) {\n                callback({\n                    text: `Error in cross-chain transfer: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (_runtime: IAgentRuntime) => true,\n    examples: [\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Please transfer 1 DOT from Polkadot to Moonbeam address 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n                    action: 'CROSS_CHAIN_TRANSFER',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Cross-chain transfer of 1 DOT from Polkadot to 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty on Moonbeam initiated. Transaction hash: 0x...',\n                },\n            },\n        ],\n        [\n            {\n                name: '{{user1}}',\n                content: {\n                    text: 'Send 0.5 GLMR from Moonbeam to 0xF977814e90dA44bFA03b6295A0616a897441aceC on Moonriver from wallet #2',\n                    action: 'CROSS_CHAIN_TRANSFER',\n                },\n            },\n            {\n                name: '{{user2}}',\n                content: {\n                    text: 'Cross-chain transfer of 0.5 GLMR from Moonbeam to 0xF977814e90dA44bFA03b6295A0616a897441aceC on Moonriver from wallet #2 initiated. Transaction hash: 0x...',\n                },\n            },\n        ],\n    ],\n};\n","import { z } from 'zod';\n\nexport const CHAIN_RPC_MAPPING: Record<string, string> = {\n    polkadot: 'wss://rpc.polkadot.io',\n    paseo: 'wss://rpc.paseo.io',\n    kusama: 'wss://kusama-rpc.polkadot.io',\n    westend: 'wss://westend-rpc.polkadot.io',\n    moonbeam: 'wss://wss.api.moonbeam.network',\n    moonriver: 'wss://moonriver.public.blastapi.io',\n    astar: 'wss://astar-rpc.dwellir.com',\n    shiden: 'wss://shiden-rpc.dwellir.com',\n    acala: 'wss://acala-rpc.dwellir.com',\n    karura: 'wss://karura-rpc.dwellir.com',\n    bifrost: 'wss://bifrost-rpc.dwellir.com',\n    parallel: 'wss://parallel-rpc.dwellir.com',\n    heiko: 'wss://heiko-rpc.dwellir.com',\n    kilt: 'wss://spiritnet.kilt.io',\n    phala: 'wss://phala-rpc.dwellir.com',\n    khala: 'wss://khala-rpc.dwellir.com',\n    crust: 'wss://crust-rpc.dwellir.com',\n    unique: 'wss://unique-rpc.dwellir.com',\n    quartz: 'wss://quartz-rpc.dwellir.com',\n    litmus: 'wss://litmus-rpc.dwellir.com',\n    robonomics: 'wss://robonomics-rpc.dwellir.com',\n    subsocial: 'wss://subsocial-rpc.dwellir.com',\n    zeitgeist: 'wss://zeitgeist-rpc.dwellir.com',\n    basilisk: 'wss://basilisk-rpc.dwellir.com',\n    hydradx: 'wss://hydradx-rpc.dwellir.com',\n    altair: 'wss://altair-rpc.dwellir.com',\n    kintsugi: 'wss://kintsugi-rpc.dwellir.com',\n    interlay: 'wss://interlay-rpc.dwellir.com',\n    centrifuge: 'wss://centrifuge-rpc.dwellir.com',\n    calamari: 'wss://calamari-rpc.dwellir.com',\n    manta: 'wss://manta-rpc.dwellir.com',\n    turing: 'wss://turing-rpc.dwellir.com',\n    integritee: 'wss://integritee-rpc.dwellir.com',\n    nodle: 'wss://nodle-rpc.dwellir.com',\n    efinity: 'wss://efinity-rpc.dwellir.com',\n    darwinia: 'wss://darwinia-rpc.dwellir.com',\n    crab: 'wss://crab-rpc.dwellir.com',\n    pioneer: 'wss://pioneer-rpc.dwellir.com',\n    bitcountry: 'wss://bitcountry-rpc.dwellir.com',\n    subdao: 'wss://subdao-rpc.dwellir.com',\n    subgame: 'wss://subgame-rpc.dwellir.com',\n    subspace: 'wss://subspace-rpc.dwellir.com',\n    ternoa: 'wss://ternoa-rpc.dwellir.com',\n    zero: 'wss://zero-rpc.dwellir.com',\n    encointer: 'wss://encointer-rpc.dwellir.com',\n    kylin: 'wss://kylin-rpc.dwellir.com',\n    polymesh: 'wss://polymesh-rpc.dwellir.com',\n    equilibrium: 'wss://equilibrium-rpc.dwellir.com',\n    chainx: 'wss://chainx-rpc.dwellir.com',\n    edgeware: 'wss://edgeware-rpc.dwellir.com',\n    kulupu: 'wss://kulupu-rpc.dwellir.com',\n    joystream: 'wss://joystream-rpc.dwellir.com',\n    dock: 'wss://dock-rpc.dwellir.com',\n    stafi: 'wss://stafi-rpc.dwellir.com',\n    sora: 'wss://sora-rpc.dwellir.com',\n    substrate: 'wss://substrate-rpc.dwellir.com',\n};\n\nexport const CHAIN_ID_MAPPING: Record<string, string> = {\n    polkadot: '0',\n    paseo: '0',\n    kusama: '2',\n    westend: '0',\n    substrate: '0',\n    acala: '2000',\n    ajuna: '2051',\n    astar: '2006',\n    bitfrost: '2030',\n    hydradx: '2034',\n    moonbeam: '2004',\n    phala: '2035',\n    assetHubPolkadot: '1000',\n    polkadotBridgeHub: '1002',\n    polkadotCollectives: '1001',\n    bajun: '2119',\n    basilisk: '2090',\n    bitfrostKusama: '2001',\n    karura: '2000',\n    khala: '2004',\n    assetHubKusama: '1000',\n    kusamaBridgeHub: '1002',\n    moonriver: '2023',\n    shiden: '2007',\n    tinkernet: '2125',\n    moonbase: '1000',\n    rococoContracts: '1002',\n    rococoAssetHub: '1000',\n    rococoBridgeHub: '1013',\n    rococoCoretime: '1013',\n    tangleRococo: '4006',\n    watr: '2058',\n    tokyoShibuya: '1000',\n    westendAssetHub: '1000',\n    westendBridgeHub: '1002',\n    westendCollectives: '1001',\n    wococoBridgeHub: '1014',\n    wococoWockmint: '1000',\n};\n\n// Zod Schemas for Registry Validation\nexport const AssetDetailsSchema = z.object({\n    asset: z.string(),\n    symbol: z.string(),\n    decimals: z.number(),\n});\nexport type AssetDetails = z.infer<typeof AssetDetailsSchema>;\n\nexport const SpecRegistrySchema = z.record(z.string(), AssetDetailsSchema);\nexport type SpecRegistry = z.infer<typeof SpecRegistrySchema>;\n\nexport const RegistryAssetInfoEntrySchema = z.object({\n    tokens: z.array(z.string()),\n    assetsInfo: z.record(z.string(), z.string()),\n    foreignAssetsInfo: z.record(z.string(), z.union([z.string(), z.record(z.unknown())])),\n    poolPairsInfo: z.record(z.string(), z.union([z.string(), z.record(z.unknown())])),\n    specName: z.string(),\n    nativeChainID: z.string().optional(),\n    registry: z.record(z.string(), SpecRegistrySchema).optional(),\n});\nexport type RegistryAssetInfoEntry = z.infer<typeof RegistryAssetInfoEntrySchema>;\n\nexport const RegistryChainEntriesSchema = z.record(z.string(), RegistryAssetInfoEntrySchema);\nexport type RegistryChainEntries = z.infer<typeof RegistryChainEntriesSchema>;\n\nexport const FullRegistryDataSchema = z.record(z.string(), RegistryChainEntriesSchema);\nexport type FullRegistryData = z.infer<typeof FullRegistryDataSchema>;\n\nexport interface ChainMetadata {\n    decimals: number;\n    tokenSymbol: string;\n    chainId: string; // This is the genesis hash\n    rpcUrl: string;\n}\n","import type { Plugin } from '@elizaos/core';\nimport createWalletAction from './actions/createWallet.ts';\nimport ejectWalletAction from './actions/ejectWallet.ts';\nimport signMessageAction from './actions/signMessage.ts';\nimport loadWalletAction from './actions/loadWallet.ts';\nimport validateSignatureAction from './actions/validateSignature.ts';\nimport getBalanceAction from './actions/getBalance.ts';\nimport getBlockInfoAction from './actions/getBlockInfo.ts';\nimport getBlockEventsAction from './actions/getBlockEvents.ts';\nimport getReferendaAction from './actions/getReferenda.ts';\nimport getReferendumDetailsAction from './actions/getReferendumDetails.ts';\nimport { WalletProvider, nativeWalletProvider } from './providers/wallet.ts';\nimport networkDataProvider from './providers/networkData.ts';\nimport transferFundsAction from './actions/transferFunds.ts';\nimport crossChainTransferAction from './actions/crossChainTransfer.ts';\n\nexport {\n    WalletProvider,\n    createWalletAction as CreatePolkadotWallet,\n    ejectWalletAction as EjectPolkadotWallet,\n    signMessageAction as SignPolkadotMessage,\n    loadWalletAction as LoadPolkadotWallet,\n    getBalanceAction as GetBalance,\n    getBlockInfoAction as GetBlockInfo,\n    getBlockEventsAction as GetBlockEvents,\n    getReferendaAction as GetReferenda,\n    getReferendumDetailsAction as GetReferendumDetails,\n    validateSignatureAction as ValidateSignature,\n    transferFundsAction as TransferPolkadotFunds,\n    crossChainTransferAction as CrossChainTransfer,\n};\n\nexport const polkadotPlugin: Plugin = {\n    name: 'polkadot',\n    description: 'Polkadot Plugin for Eliza',\n    actions: [\n        createWalletAction,\n        ejectWalletAction,\n        signMessageAction,\n        loadWalletAction,\n        getBalanceAction,\n        getBlockInfoAction,\n        getBlockEventsAction,\n        getReferendaAction,\n        getReferendumDetailsAction,\n        validateSignatureAction,\n        transferFundsAction,\n        crossChainTransferAction,\n    ],\n    evaluators: [],\n    providers: [nativeWalletProvider, networkDataProvider],\n};\n\nexport default polkadotPlugin;\n"],"mappings":"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","names":["elizaLogger","elizaLogger","elizaLogger","elizaLogger","z","parsedResponse","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","result","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","stringToU8a","u8aToHex","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","stringToU8a","hexToU8a","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","elizaLogger","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","getTrackName","formatReferendumStatus","formatTokenAmount","elizaLogger","elizaLogger","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger","elizaLogger","ModelType","composePromptFromState","parseJSONObjectFromText","z","z","z","composePromptFromState","ModelType","parsedResponse","parseJSONObjectFromText","elizaLogger"]}